#!/usr/bin/env python3

import curses
import subprocess
import shutil
import tempfile
import sys
import os
import base64
import gzip
import random
import time
import signal
import tempfile
from io import BytesIO
from datetime import datetime
from datetime import datetime, timezone

# Config from argument
if len(sys.argv) < 2:
    print("Usage: keystoreterm <keystore-file>")
    sys.exit(1)

ORIGINAL_KEYSTORE_PATH = sys.argv[1]
if not os.path.isfile(ORIGINAL_KEYSTORE_PATH):
    print(f"File not found: {ORIGINAL_KEYSTORE_PATH}")
    sys.exit(1)

KEYSTORE_COPY_PATH = tempfile.NamedTemporaryFile(delete=False, suffix=".jks").name
KEYSTORE_PATH = KEYSTORE_COPY_PATH
shutil.copyfile(ORIGINAL_KEYSTORE_PATH, KEYSTORE_COPY_PATH)

# Logo position
LOGO_X = 4
LOGO_Y = 2

# Colors
COLOR_EXPIRED_RED = 196
COLOR_EXPIRED_RED_DIM = 197

# Pairs
COLOR_PAIR_SELECTED = 1
COLOR_PAIR_SELECTED_DIM = 2
COLOR_PAIR_SELECTED_DIM_MORE = 3
COLOR_PAIR_HEADER = 4
COLOR_PAIR_MENU = 5
COLOR_PAIR_FKEYS = 6
COLOR_PAIR_WHITE = 7
COLOR_PAIR_WHITE_DIM = 8
COLOR_PAIR_CYAN = 9
COLOR_PAIR_CYAN_DIM = 10
COLOR_PAIR_EXPIRED = 11
COLOR_PAIR_EXPIRED_DIM = 12
COLOR_PAIR_DARK = 13
COLOR_PAIR_DARKER = 14
COLOR_PAIR_FIELD = 15

# Mouse support constants
LEFT_PANEL = 0
RIGHT_PANEL = 1

# Menu, footer and other settings
BUTTON_SPACING = 4
MENU_SPACING = 3
MENU_ITEMS = ["Left", "File", "Options", "Right"]
FOOTER_OPTIONS = [" 1Help", " 2GenKeyPair", " 3ImpCert", " 4ImpKeyPair", " 5ImpFromWeb", " 6SetPwd", " 7Save", " 8Delete", " 9PullDn", "10Quit"]

MOUSE_ENABLED = True
RIGHT_PANEL_HIGHLIGHT_TERM = None
RELOAD_ENTRIES = False
FILTER_STATE = {
    "name": "",
    "partial_name": "Yes",
    "valid": "Yes",
    "expired": "Yes",
    "keys": "Yes",
    "certificates": "Yes"
}

def init_curses():
    curses.set_escdelay(25) # Esc key faster
    curses.curs_set(0)
    curses.start_color()
    curses.use_default_colors()
    curses.init_color(COLOR_EXPIRED_RED, 750, 200, 200)
    curses.init_color(COLOR_EXPIRED_RED_DIM, 600, 150, 150)
    curses.init_pair(COLOR_PAIR_SELECTED, curses.COLOR_BLACK, curses.COLOR_CYAN)
    curses.init_pair(COLOR_PAIR_SELECTED_DIM, curses.COLOR_BLACK, 73)
    curses.init_pair(COLOR_PAIR_SELECTED_DIM_MORE, curses.COLOR_BLACK, 23)
    curses.init_pair(COLOR_PAIR_HEADER, curses.COLOR_YELLOW, -1)
    curses.init_pair(COLOR_PAIR_MENU, curses.COLOR_BLACK, curses.COLOR_YELLOW)
    curses.init_pair(COLOR_PAIR_FKEYS, curses.COLOR_BLACK, curses.COLOR_WHITE)
    curses.init_pair(COLOR_PAIR_WHITE, 231, -1)
    curses.init_pair(COLOR_PAIR_WHITE_DIM, curses.COLOR_WHITE, -1)
    curses.init_pair(COLOR_PAIR_DARK, 245, -1)
    curses.init_pair(COLOR_PAIR_DARKER, 237, -1)
    curses.init_pair(COLOR_PAIR_CYAN, 116, -1)
    curses.init_pair(COLOR_PAIR_CYAN_DIM, 73, -1)
    curses.init_pair(COLOR_PAIR_EXPIRED, COLOR_EXPIRED_RED, -1)
    curses.init_pair(COLOR_PAIR_EXPIRED_DIM, COLOR_EXPIRED_RED_DIM, -1)
    curses.init_pair(COLOR_PAIR_FIELD, curses.COLOR_WHITE, 234)
    curses.mousemask(curses.ALL_MOUSE_EVENTS | curses.REPORT_MOUSE_POSITION)

def file_picker(stdscr, start_path=".", title="Select a file", extensions=None):
    win_height = 20
    win_width = 70
    height, width = stdscr.getmaxyx()
    start_y = (height - win_height) // 2
    start_x = (width - win_width) // 2

    current_path = os.path.abspath(start_path)
    selected_index = 0
    scroll_offset = 0

    curses.curs_set(0)
    win = curses.newwin(win_height, win_width, start_y, start_x)
    win.keypad(True)
    popup_box(win, f"{title}: {current_path}")

    while True:
        clear_window(win)
        try:
            entries = os.listdir(current_path)
            entries = [e for e in entries if os.path.isdir(os.path.join(current_path, e)) or not extensions or any(e.lower().endswith(ext) for ext in extensions)]
            entries.sort()
            entries = [".."] + entries
        except PermissionError:
            entries = [".."]

        visible_height = win_height - 3  # account for header
        visible_entries = entries[scroll_offset:scroll_offset + visible_height]

        if selected_index >= len(entries):
            selected_index = len(entries) - 1

        win.addstr(1, 1, f" {'Name':<35} {'Size':>9} {'Modified':>20}", curses.A_BOLD)

        for idx, entry in enumerate(visible_entries):
            actual_index = scroll_offset + idx
            entry_path = os.path.join(current_path, entries[actual_index])
            is_dir = os.path.isdir(entry_path)
            is_cert = entry_path.endswith(('.crt', '.cer', '.pem'))
            is_key = entry_path.endswith(('.key', '.p12', '.pfx', '.jks'))
            is_selected = actual_index == selected_index

            try:
                size = os.path.getsize(entry_path)
                mtime = time.strftime('%Y-%m-%d %H:%M', time.localtime(os.path.getmtime(entry_path)))
            except Exception:
                size = 0
                mtime = ""

            size_str = f"{size:,}" if not is_dir else "<DIR>"
            name_str = f"{entry}/" if is_dir else entry
            if is_selected:
                attr = curses.color_pair(COLOR_PAIR_SELECTED)
            elif is_cert:
                attr = curses.color_pair(COLOR_PAIR_HEADER)
            elif is_key:
                attr = curses.color_pair(COLOR_PAIR_EXPIRED)
            else:
                attr = curses.A_NORMAL

            win.addstr(idx + 2, 1, f" {name_str:<35.35} {size_str:>9} {mtime:>20}", attr)

        key = win.getch()

        if key in [curses.KEY_UP, ord("k")]:
            if selected_index > 0:
                selected_index -= 1
        elif key in [curses.KEY_DOWN, ord("j")]:
            if selected_index < len(entries) - 1:
                selected_index += 1
        elif key in [10, 13]:
            selected_entry = entries[selected_index]
            full_path = os.path.join(current_path, selected_entry)
            if os.path.isdir(full_path):
                current_path = os.path.abspath(full_path)
                selected_index = 0
                scroll_offset = 0
            else:
                win.clear()
                win.refresh()
                return os.path.abspath(full_path)
        elif key in [27]:
            win.clear()
            win.refresh()
            return None

        if selected_index < scroll_offset:
            scroll_offset = selected_index
        elif selected_index >= scroll_offset + visible_height:
            scroll_offset = selected_index - visible_height + 1

def popup_form(stdscr, title, labels, file_fields=None, masked_fields=None, choice_fields=None, dependencies=None, choice_labels=None, default_values=None, placeholder_values=None, buttons=None):
    height, width = stdscr.getmaxyx()
    win_width = 75
    win_height = 2 * len(labels) + 6
    start_y = (height - win_height) // 2
    start_x = (width - win_width) // 2
    buttons = buttons or [" OK ", " Cancel "]

    file_fields = file_fields or []
    masked_fields = masked_fields or []
    choice_fields = choice_fields or []
    dependencies = dependencies or {}
    choice_labels = choice_labels or {i: ("Yes", "No") for i in choice_fields}
    default_values = default_values or {}
    placeholder_values = placeholder_values or {}

    values = [
        default_values.get(i, choice_labels[i][0] if i in choice_fields else "")
        for i in range(len(labels))
    ]
    current = 0
    selected_button = 0
    in_buttons = False

    win = curses.newwin(win_height, win_width, start_y, start_x)
    win.keypad(True)
    field_start_x = max(len(label) for label in labels)

    while True:
        popup_box(win, title)

        for y in range(2, win_height - 3):
            win.addstr(y, 2, " " * (win_width - 4))

        visible_fields = []
        for i, label in enumerate(labels):
            dep = dependencies.get(i)
            if dep:
                dep_idx, expected = dep
                if values[dep_idx] != expected:
                    continue

            visible_fields.append(i)
            y = 2 + 2 * len(visible_fields) - 2
            is_selected = not in_buttons and i == current

            if i in choice_fields:
                options = choice_labels.get(i, ("Yes", "No"))
                selected_value = values[i]
                win.addstr(y, field_start_x - len(label) + 2, label)

                x = field_start_x + 3
                for opt in options:
                    attr = curses.A_NORMAL
                    if is_selected and selected_value == opt:
                        attr |= curses.A_REVERSE
                    elif not is_selected and selected_value == opt:
                        attr = curses.color_pair(COLOR_PAIR_MENU)

                    win.addstr(y, x, f" {opt} ", attr)
                    x += len(opt) + 3
            else:
                val = values[i] if i not in masked_fields else '*' * len(values[i])

                placeholder = placeholder_values.get(i)
                if not placeholder and i in file_fields:
                    placeholder = "Type path or press enter to browse"

                if is_selected and not values[i] and placeholder:
                    display_val = placeholder
                    attr = curses.A_REVERSE | curses.A_DIM
                else:
                    display_val = val
                    attr = curses.A_REVERSE if is_selected else curses.color_pair(COLOR_PAIR_FIELD)

                win.addstr(y, field_start_x - len(label) + 2, label)
                win.addstr(y, field_start_x + 3, display_val[:win_width - field_start_x - 5].ljust(win_width - field_start_x - 5), attr)

        btn_y = win_height - 2
        btn_x = (win_width - sum(len(b) for b in buttons) - BUTTON_SPACING) // 2
        for i, btn in enumerate(buttons):
            attr = curses.A_REVERSE if in_buttons and selected_button == i else curses.color_pair(COLOR_PAIR_FIELD)
            win.addstr(btn_y, btn_x, btn, attr)
            btn_x += len(btn) + BUTTON_SPACING

        if not in_buttons and current in visible_fields:
            y = 2 + 2 * visible_fields.index(current)
            if current in choice_fields:
                options = choice_labels[current]
                selected_index = options.index(values[current])
                x = field_start_x + 3 + sum(len(opt) + 3 for opt in options[:selected_index])
                win.move(y, x + 1)
            else:
                val = values[current] if current not in masked_fields else '*' * len(values[current])
                win.move(y, min(field_start_x + 3 + len(val), win_width - 2))

        win.refresh()
        key = win.getch()

        if key == 27:
            return None, win

        if not in_buttons:
            if key == curses.KEY_UP:
                idx = visible_fields.index(current)
                if idx > 0:
                    current = visible_fields[idx - 1]
            elif key == curses.KEY_DOWN:
                idx = visible_fields.index(current)
                if idx < len(visible_fields) - 1:
                    current = visible_fields[idx + 1]
                else:
                    in_buttons = True
                    selected_button = 0
            elif current in choice_fields:
                opts = choice_labels.get(current, ("Yes", "No"))
                idx = opts.index(values[current])
                if key == curses.KEY_LEFT:
                    values[current] = opts[(idx - 1) % len(opts)]
                elif key == curses.KEY_RIGHT:
                    values[current] = opts[(idx + 1) % len(opts)]
            elif key in [curses.KEY_BACKSPACE, 127, 8]:
                values[current] = values[current][:-1]
            elif 32 <= key <= 126 and len(values[current]) < 60:
                values[current] += chr(key)
            elif key in [10, 13] and current in file_fields:
                path = file_picker(stdscr, ".", "Select a file", [".key", ".p12", ".cer", ".pem", ".crt", ".jks"])
                if path:
                    values[current] = path
        else:
            if key in [curses.KEY_LEFT, curses.KEY_RIGHT]:
                selected_button = 1 - selected_button
            elif key in [10, 13]:
                if selected_button == 0:
                    curses.noecho()
                    return {
                        labels[i].rstrip(':?#').lower().replace(' ', '_'): values[i].strip()
                        for i in visible_fields
                    }, win
                return None, win
            elif key == curses.KEY_UP:
                in_buttons = False

def clear_window(win):
    height, width = win.getmaxyx()
    for y in range(1, height - 1):
        win.move(y, 1)
        win.addstr(y, 1, " " * (width - 2))

def prompt_import_key_type(stdscr):
    key_types = ["PKCS #12", "PKCS #8", "PVK", "OpenSSL"]
    height, width = stdscr.getmaxyx()
    win_height = len(key_types) + 4
    win_width = max(len(t) for t in key_types) + 13
    win = curses.newwin(win_height, win_width, (height - win_height) // 2, (width - win_width) // 2)
    win.keypad(True)
    popup_box(win, "Import Key Pair")
    selected = 0

    while True:
        for i, option in enumerate(key_types):
            mode = curses.A_REVERSE if i == selected else curses.A_NORMAL
            win.addstr(2 + i, 4, option.ljust(win_width - 8), mode)
        win.refresh()
        key = win.getch()
        if key == curses.KEY_UP and selected > 0:
            selected -= 1
        elif key == curses.KEY_DOWN and selected < len(key_types) - 1:
            selected += 1
        elif key in [10, 13]:
            return key_types[selected]
        elif key in [27]:
            return None

def handle_import_result(alias, result, win):
    win_height, win_width = win.getmaxyx()
    if result.returncode == 0:
        win.addstr(3, 2, f"Successfully imported: {alias}", curses.A_BOLD)
        win.addstr(win_height - 3, 2, "Press any key to continue.")
        win.refresh()
        win.getch()
        return alias
    else:
        win.addstr(3, 2, "Import failed:", curses.A_BOLD)
        win.addstr(4, 2, result.stdout.strip()[:win_width - 4])
        win.addstr(win_height - 3, 2, "Press any key to continue.")
        win.refresh()
        win.getch()
        return None

def import_pkcs12_keypair(stdscr, keystore_path, keystore_pass):
    form_data, win = popup_form(
        stdscr,
        title="Import PKCS #12 Key Pair",
        labels=[
            "Key pair file:",
            "Decryption password:"
        ],
        file_fields=[0],
        masked_fields=[1]
    )

    if form_data is None or "key_pair_file" not in form_data:
        return None

    clear_window(win)
    win.addstr(2, 2, "Importing key pair...", curses.A_BOLD)

    alias = os.path.splitext(os.path.basename(form_data['key_pair_file']))[0]
    cmd = [
        "keytool", "-importkeystore",
        "-srckeystore", form_data['key_pair_file'],
        "-srcstoretype", "PKCS12",
        "-destkeystore", keystore_path,
        "-deststorepass", keystore_pass,
        "-srcstorepass", form_data['decryption_password'],
        "-alias", alias,
        "-destalias", alias
    ]
    result = subprocess.run(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
    return handle_import_result(alias, result, win)

def import_pkcs8_keypair(stdscr, keystore_path, keystore_pass):
    form_data, win = popup_form(
        stdscr,
        title="Import PKCS #8 Key Pair",
        labels=[
            "Certificates file:",
            "PKCS8 key file:",
            "Encrypted key?",
            "Decryption password:"
        ],
        file_fields=[0, 1],
        masked_fields=[3],
        choice_fields=[2],
        dependencies={3: (2, "Yes")},  # Show password only if encrypted == yes
        choice_labels={2: ("Yes", "No")}
    )

    if form_data is None or "certificates_file" not in form_data:
        return None

    with tempfile.NamedTemporaryFile(delete=False, suffix=".p12") as p12_file:
        p12_path = p12_file.name

    clear_window(win)
    _, win_width = win.getmaxyx()
    win.addstr(2, 2, "Importing key pair...", curses.A_BOLD)

    alias = os.path.splitext(os.path.basename(form_data['pkcs8_key_file']))[0]

    openssl_cmd = [
        "openssl", "pkcs12",
        "-export",
        "-in", form_data['certificates_file'],
        "-inkey", form_data['pkcs8_key_file'],
        "-out", p12_path,
        "-name", alias,
        "-passout", f"pass:{keystore_pass}"
    ]

    if form_data is not None and "decryption_password" in form_data:
        openssl_cmd += ["-passin", f"pass:{form_data['decryption_password']}"]

    keytool_cmd = [
        "keytool", "-importkeystore",
        "-deststorepass", keystore_pass,
        "-destkeypass", keystore_pass,
        "-destkeystore", keystore_path,
        "-srckeystore", p12_path,
        "-srcstoretype", "PKCS12",
        "-srcstorepass", keystore_pass,
        "-alias", alias,
        "-noprompt"
    ]

    try:
        # Run OpenSSL to convert key
        openssl_result = subprocess.run(openssl_cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
        if openssl_result.returncode != 0:
            win.addstr(3, 2, "OpenSSL conversion failed:", curses.A_BOLD)
            win.addstr(4, 2, openssl_result.stdout.strip()[:win_width - 4])
        else:
            result = subprocess.run(keytool_cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
            return handle_import_result(alias, result, win)
    finally:
        if os.path.exists(p12_path):
            os.remove(p12_path)

def import_cert_file(stdscr, password):
    form_data, win = popup_form(
        stdscr,
        title="Import Certificate from file",
        labels=["File path:"],
        file_fields=[0]
    )

    if form_data is None or "file_path" not in form_data:
        return None

    cert_file = form_data["file_path"]
    alias = os.path.splitext(os.path.basename(cert_file))[0]
    import_cmd = [
        "keytool", "-importcert",
        "-alias", alias,
        "-keystore", KEYSTORE_PATH,
        "-storepass", password,
        "-file", cert_file,
        "-noprompt"
    ]
    clear_window(win)
    win.addstr(2, 2, f"Importing {cert_file}...", curses.A_BOLD)
    win.refresh()
    result = subprocess.run(import_cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
    return handle_import_result(alias, result, win)

def import_cert_from_url(stdscr, password):
    form_data, win = popup_form(
                    stdscr,
                    title="Import SSL Certificate from URL",
                    labels=["Url:"],
                    placeholder_values={0: "example:443"}
                )

    if form_data is None or "url" not in form_data:
        return None

    url = form_data["url"]
    clear_window(win)
    win.addstr(2, 2, f"Fetching certificate from {url}...")
    if url.startswith("https://") or url.startswith("http://"):
        url = url.split("://", 1)[1]

    parts = url.split(":")
    host = parts[0]
    port = parts[1] if len(parts) > 1 else "443"

    cert_path = f"/tmp/cert_from_{url.replace(':', '_').replace('/', '_')}.crt"
    cmd = [
        "openssl", "s_client", "-showcerts",
        "-servername", host,
        "-connect", f"{host}:{port}"
    ]
    fetch = subprocess.run(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.DEVNULL, text=True, timeout=5)
    start = fetch.stdout.find("-----BEGIN CERTIFICATE-----")
    end = fetch.stdout.find("-----END CERTIFICATE-----") + len("-----END CERTIFICATE-----")
    cert = fetch.stdout[start:end]

    if "-----BEGIN CERTIFICATE-----" not in cert:
        raise Exception("Could not extract certificate")

    with open(cert_path, "w") as f:
        f.write(cert)

    alias = host
    import_cmd = [
        "keytool", "-importcert",
        "-alias", alias,
        "-keystore", KEYSTORE_PATH,
        "-storepass", password,
        "-file", cert_path,
        "-noprompt"
    ]
    result = subprocess.run(import_cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
    return handle_import_result(alias, result, win)

def delete_entry(password, alias):
    confirm_height, confirm_width = 8, 60
    confirm_y = (curses.LINES - confirm_height) // 2
    confirm_x = (curses.COLS - confirm_width) // 2
    confirm_win = curses.newwin(confirm_height, confirm_width, confirm_y, confirm_x)
    confirm_win.keypad(True)
    popup_box(confirm_win, "Delete entry?")
    confirm_win.addstr(2, 2, f"Entry will be deleted:")
    confirm_win.addstr(3, 2, f"{alias} ", curses.A_BOLD)
    options = ["Yes", "No"]
    selected_option = 1
    while True:
        btn_y = confirm_height - 2
        btn_x = (confirm_width - sum(len(b) for b in options) - BUTTON_SPACING) // 2
        for i, btn in enumerate(options):
            attr = curses.A_REVERSE if selected_option == i else curses.color_pair(COLOR_PAIR_FIELD)
            confirm_win.addstr(btn_y, btn_x, f" {btn} ", attr)
            btn_x += len(btn) + BUTTON_SPACING
        confirm_win.refresh()
        ch = confirm_win.getch()
        if ch in [curses.KEY_LEFT, curses.KEY_RIGHT]:
            selected_option = 1 - selected_option
        elif ch in [10, 13]:
            if selected_option == 0:
                delete_cmd = ["keytool", "-delete", "-alias", alias, "-keystore", KEYSTORE_PATH, "-storepass", password]
                result = subprocess.run(delete_cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
                if result.returncode == 0:
                    return check_unsaved_changes()
                else:
                    confirm_win.erase()
                    confirm_win.addstr(0, 2, "Deletion failed:", curses.A_BOLD)
                    confirm_win.addstr(2, 2, result.stderr.strip())
                    confirm_win.refresh()
                    confirm_win.getch()
            return False
        elif ch in [27]:
            return False

def check_password(keystore_path, password):
    try:
        subprocess.run(
            ["keytool", "-list", "-keystore", keystore_path, "-storepass", password],
            check=True,
            stdout=subprocess.DEVNULL,
            stderr=subprocess.DEVNULL
        )
        return True
    except subprocess.CalledProcessError:
        return False

def check_unsaved_changes():
    try:
        with open(ORIGINAL_KEYSTORE_PATH, 'rb') as f1, open(KEYSTORE_PATH, 'rb') as f2:
            return f1.read() != f2.read()
    except Exception:
        return True

def save_changes(has_unsaved_changes):
    if not has_unsaved_changes:
        return False

    confirm_height, confirm_width = 7, 50
    confirm_y = (curses.LINES - confirm_height) // 2
    confirm_x = (curses.COLS - confirm_width) // 2
    confirm_win = curses.newwin(confirm_height, confirm_width, confirm_y, confirm_x)
    confirm_win.keypad(True)
    popup_box(confirm_win, "Save changes?")
    confirm_win.addstr(2, 2, "Overwrite the original keystore?")
    options = ["Yes", "No"]
    selected_option = 1
    while True:
        btn_y = confirm_height - 2
        btn_x = (confirm_width - sum(len(b) for b in options) - BUTTON_SPACING) // 2
        for i, btn in enumerate(options):
            attr = curses.A_REVERSE if selected_option == i else curses.color_pair(COLOR_PAIR_FIELD)
            confirm_win.addstr(btn_y, btn_x, f" {btn} ", attr)
            btn_x += len(btn) + BUTTON_SPACING
        confirm_win.refresh()
        ch = confirm_win.getch()
        if ch in [curses.KEY_LEFT, curses.KEY_RIGHT]:
            selected_option = (selected_option + 1) % len(options)
        elif ch in [10, 13]:
            if selected_option == 0:
                shutil.copyfile(KEYSTORE_PATH, ORIGINAL_KEYSTORE_PATH)
                confirm_win.addstr(5, 2, "Saving:")
                for i in range(30):
                    confirm_win.addstr(5, 10 + i, "█")
                    confirm_win.refresh()
                    curses.napms(20)
                return False
            return True
        elif ch in [27]:
            return True

def filter_entries(entries):
    filtered = []
    for entry in entries:
        alias = entry.get("Alias name", "").lower()

        if FILTER_STATE["name"]:
            if FILTER_STATE["partial_name"] == "Yes":
                if FILTER_STATE["name"].lower() not in alias:
                    continue
            else:
                if FILTER_STATE["name"].lower() != alias:
                    continue

        if FILTER_STATE["expired"] == "No" and entry.get("__expired__", False):
            continue

        if FILTER_STATE["valid"] == "No" and not entry.get("__expired__", False):
            continue

        if FILTER_STATE["keys"] == "No" and entry.get("__is_key__", False):
            continue

        if FILTER_STATE["certificates"] == "No" and entry.get("__is_cert__", False):
            continue

        filtered.append(entry)
    return filtered

def get_keystore_entries(path, password):
    cmd = ["keytool", "-list", "-v", "-keystore", path, "-storepass", password]
    result = subprocess.run(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
    if result.returncode != 0:
        raise Exception("Failed to load keystore:\n" + result.stderr)

    entries = []
    current_entry = {}
    lines = result.stdout.splitlines()[4:]  # Skip first 4 lines
    for line in lines:
        line = line.strip()
        if line.startswith("Alias name:"):
            if current_entry:
                entries.append(current_entry)
            current_entry = {"Alias name": line.split("Alias name:")[1].strip()}
        elif ":" in line:
            key, value = map(str.strip, line.split(":", 1))
            current_entry[key] = value
    if current_entry:
        entries.append(current_entry)

    # Pre-render each entry's details into strings
    for entry in entries:
        detail_lines = []
        priority = ["Alias name", "Entry type", "Creation date", "Valid from"]
        keys = priority + [k for k in entry if k not in priority]
        for key in keys:
            value = entry.get(key, "")
            detail_lines.append((key, value))
        entry["__rendered__"] = detail_lines

        # Detect expiration
        valid_from = entry.get("Valid from")
        if valid_from and "until:" in valid_from:
            try:
                until_str = valid_from.split("until:")[1].strip()
                until_str_clean = until_str.replace("WET", "+0000")
                until_date = datetime.strptime(until_str_clean, "%a %b %d %H:%M:%S %z %Y")
                entry["__expired__"] = until_date < datetime.now(timezone.utc)
            except Exception:
                entry["__expired__"] = False
        else:
            entry["__expired__"] = False

    return filter_entries(entries)

def find_entry_index_by_alias(entries, alias):
    for i, entry in enumerate(entries):
        if entry.get("Alias name") == alias:
            return i
    return 0

def draw_menu_bar(active_menu, width):
    bar_win = curses.newwin(1, width, 0, 0)
    bar_win.bkgd(' ', curses.color_pair(COLOR_PAIR_MENU))
    x = 1
    for i, item in enumerate(MENU_ITEMS):
        if i == active_menu:
            bar_win.attron(curses.A_REVERSE)
        bar_win.addstr(0, x + (i * MENU_SPACING), f" {item} ")
        bar_win.attroff(curses.A_REVERSE)
        x += len(item) + 2
    bar_win.refresh()

def menu_modal(stdscr, has_unsaved_changes, active_menu=0, redraw_main_ui=None):
    submenus = {
        "Left": ["Filter"],
        "File": ["Open keystore", "Quit"],
        "Options": ["Enable/Disable mouse"],
        "Right": ["Search content"]
    }

    selected_index = None
    _, width = stdscr.getmaxyx()

    def handle_filter_popup():
        global FILTER_STATE
        global RELOAD_ENTRIES
        form_data, _ = popup_form(
            stdscr,
            title="Filter entries",
            labels=[
                "Name:",
                "Partial name:",
                "Valid:",
                "Expired:",
                "Keys:",
                "Certificates:"
            ],
            choice_fields=[1, 2, 3, 4, 5],
            choice_labels={
                1: ("Yes", "No"),
                2: ("Yes", "No"),
                3: ("Yes", "No"),
                4: ("Yes", "No"),
                5: ("Yes", "No")
            }
        )
        if form_data:
            FILTER_STATE.update(form_data)
            RELOAD_ENTRIES = True

    def handle_open_keystore(stdscr):
        global KEYSTORE_PATH, password, RELOAD_ENTRIES

        KEYSTORE_PATH = file_picker(stdscr, ".", "Select a Keystore", [".jks"])

        if not KEYSTORE_PATH:
            return

        try:
            intro_win = intro_window(stdscr)
            show_logo(intro_win, False)

            if not check_password(KEYSTORE_PATH, password=""):
                password = prompt_password(intro_win)
            else:
                fade_logo(intro_win)

            RELOAD_ENTRIES = True

        except Exception as e:
            stdscr.clear()
            stdscr.addstr(2, 2, f"Failed to open keystore: {e}")
            stdscr.refresh()
            stdscr.getch()

    def handle_toggle_mouse():
        global MOUSE_ENABLED
        MOUSE_ENABLED = not MOUSE_ENABLED
        if MOUSE_ENABLED:
            curses.mousemask(curses.ALL_MOUSE_EVENTS | curses.REPORT_MOUSE_POSITION)
        else:
            curses.mousemask(0)

    def handle_search_content(stdscr):
        form_data, _ = popup_form(
            stdscr,
            title="Search content",
            labels=["Search term:"],
            buttons=[" Search ", " Cancel "],
            placeholder_values={0: "Enter a word or phrase to highlight"}
        )

        if not form_data:
            return

        term = form_data.get("search_term")
        if not term:
            return

        global RIGHT_PANEL_HIGHLIGHT_TERM
        RIGHT_PANEL_HIGHLIGHT_TERM = term.lower()

    def draw_submenu():
        items = submenus[MENU_ITEMS[active_menu]]
        max_width = max(len(item) for item in items) + 4
        box_height = len(items) + 2
        start_x = 1 + sum(len(f" {MENU_ITEMS[i]} ") + MENU_SPACING for i in range(active_menu))
        start_y = 1

        submenu_win = curses.newwin(box_height, max_width, start_y, start_x)
        submenu_win.bkgd(' ', curses.color_pair(COLOR_PAIR_DARKER))
        submenu_win.box()

        for idx, label in enumerate(items):
            attr = curses.color_pair(COLOR_PAIR_MENU) if idx == selected_index else curses.color_pair(COLOR_PAIR_HEADER)
            submenu_win.addstr(1 + idx, 2, label.ljust(max_width - 4), attr)

        submenu_win.refresh()
        return submenu_win

    draw_menu_bar(active_menu, width)
    submenu_win = draw_submenu()
    submenu_bounds = {
        "x": 1 + sum(len(f" {MENU_ITEMS[i]} ") + MENU_SPACING for i in range(active_menu)),
        "y": 1,
        "width": max(len(item) for item in submenus[MENU_ITEMS[active_menu]]) + 4,
        "height": len(submenus[MENU_ITEMS[active_menu]]) + 2
    }

    while True:
        key = stdscr.getch()

        if key == curses.KEY_MOUSE:
            _, mx, my, _, mouse_event = curses.getmouse()
            if my == 0:
                x = 1
                for i, item in enumerate(MENU_ITEMS):
                    item_len = len(f" {item} ")
                    if x <= mx < x + item_len:
                        if active_menu == i:
                            if submenu_win:
                                submenu_win.clear()
                                submenu_win.refresh()
                            return None, None
                        else:
                            active_menu = i
                        if submenu_win:
                            submenu_win.clear()
                            submenu_win.refresh()
                            submenu_win = None
                            selected_index = None
                        if redraw_main_ui:
                            redraw_main_ui()
                        draw_menu_bar(active_menu, width)
                        submenu_win = draw_submenu()
                        break
                    x += item_len + MENU_SPACING

            elif submenu_win:
                if submenu_bounds:
                    if submenu_bounds["y"] < my < submenu_bounds["y"] + submenu_bounds["height"] - 1 and \
                    submenu_bounds["x"] <= mx < submenu_bounds["x"] + submenu_bounds["width"]:
                        selected_index = my - submenu_bounds["y"] - 1
                        submenu_win = draw_submenu()
                        curses.napms(35)
                        items = submenus[MENU_ITEMS[active_menu]]
                        selected_label = items[selected_index]
                        submenu_win.clear()
                        submenu_win.refresh()
                        if selected_label == "Filter":
                            handle_filter_popup()
                        elif selected_label == "Open keystore":
                            handle_open_keystore(stdscr)
                        elif selected_label == "Quit":
                            save_changes(has_unsaved_changes)
                            exit(0)
                        elif selected_label == "Enable/Disable mouse":
                            handle_toggle_mouse()
                        elif selected_label == "Search content":
                            handle_search_content(stdscr)
                        else:
                            stdscr.addstr(3, 2, f"Selected menu: {selected_label}   ")
                            stdscr.refresh()
                break

        if key == curses.KEY_LEFT:
            if submenu_win:
                submenu_win.clear()
                submenu_win.refresh()
                submenu_win = None
                selected_index = None
            active_menu = (active_menu - 1) % len(MENU_ITEMS)
            if redraw_main_ui:
                redraw_main_ui()
            draw_menu_bar(active_menu, width)
            submenu_win = draw_submenu()

        elif key == curses.KEY_RIGHT:
            if submenu_win:
                submenu_win.clear()
                submenu_win.refresh()
                submenu_win = None
                selected_index = None
            active_menu = (active_menu + 1) % len(MENU_ITEMS)
            if redraw_main_ui:
                redraw_main_ui()
            draw_menu_bar(active_menu, width)
            submenu_win = draw_submenu()

        elif key == curses.KEY_DOWN:
            if selected_index is None:
                selected_index = 0
            else:
                selected_index = (selected_index + 1) % len(submenus[MENU_ITEMS[active_menu]])
            submenu_win = draw_submenu()

        elif key == curses.KEY_UP and submenu_win:
            selected_index = (selected_index - 1) % len(submenus[MENU_ITEMS[active_menu]])
            submenu_win = draw_submenu()

        elif key == curses.KEY_DOWN and submenu_win:
            selected_index = (selected_index + 1) % len(submenus[MENU_ITEMS[active_menu]])
            submenu_win = draw_submenu()

        elif key in [10, 13] and selected_index is not None:
            selected_label = submenus[MENU_ITEMS[active_menu]][selected_index]
            if selected_label == "Filter":
                handle_filter_popup()
            elif selected_label == "Open keystore":
                handle_open_keystore(stdscr)
            elif selected_label == "Quit":
                save_changes(has_unsaved_changes)
                exit(0)
            elif selected_label == "Enable/Disable mouse":
                handle_toggle_mouse()
            elif selected_label == "Search content":
                handle_search_content(stdscr)
            if submenu_win:
                submenu_win.clear()
                submenu_win.refresh()
            return None, None

        elif key in [curses.KEY_F9, 27]:  # ESC
            if submenu_win:
                submenu_win.clear()
                submenu_win.refresh()
            return None, None

        elif key == curses.KEY_F10:
            save_changes(has_unsaved_changes)
            exit(0)

def prompt_password(win):
    import time

    win_y, win_x = win.getbegyx()
    while True:
        keypad_win = curses.newwin(1, 25, win_y + 15, win_x + 22)
        keypad_win.addstr(0, 0, " " * 24, curses.color_pair(COLOR_PAIR_FKEYS))
        keypad_win.keypad(True)
        keypad_win.move(0, 0)
        win.refresh()
        curses.curs_set(1)
        password = ""

        while True:
            ch = keypad_win.getch()
            subprocess.Popen(["afplay", "keystroke.mp3", "-v", "0.6"], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)

            if ch in [10, 13]:  # Enter
                if not check_password(KEYSTORE_PATH, password):
                    curses.curs_set(0)
                    password = ""
                    shake_logo(win)
                    keypad_win.clear()
                    keypad_win.addstr(0, 0, " " * 24, curses.color_pair(COLOR_PAIR_FKEYS))
                    keypad_win.move(0, 0)
                    curses.curs_set(1)
                else:
                    curses.curs_set(0)
                    fade_logo(win)
                    return password
            elif ch in [27]:  # ESC
                curses.curs_set(0)
                fade_logo(win)
                exit(1)
            elif ch in [curses.KEY_BACKSPACE, 127, 8]:
                if len(password) > 0:
                    password = password[:-1]
                    keypad_win.addch(0, len(password), ' ', curses.color_pair(COLOR_PAIR_FKEYS))
                    keypad_win.move(0, len(password))
            elif 32 <= ch <= 126:
                if len(password) + 1 > 24:
                    break
                if len(password) < 30:
                    password += chr(ch)

                    # Flash animation on character
                    pos = len(password) - 1
                    bright_attr = curses.color_pair(COLOR_PAIR_SELECTED) | curses.A_BOLD
                    dim_attr = curses.color_pair(COLOR_PAIR_FKEYS)
                    keypad_win.addch(0, pos, '*', bright_attr)
                    keypad_win.refresh()
                    time.sleep(0.075)
                    keypad_win.addch(0, pos, '*', dim_attr)
                    keypad_win.refresh()

def get_logo_lines():
    ascii_art_base64 = 'H4sICJNV/WcAA2tleS1hbnNpLmFucwDjUgCCR9M6cCEuVFkFdOVc6JoxVGBThB/RWjleDyMU4VAGl0IPCDRhbOpoqAguBnc3FwAUPk4X3AEAAA=='
    compressed_data = base64.b64decode(ascii_art_base64)
    with gzip.GzipFile(fileobj=BytesIO(compressed_data)) as f:
        return f.read().decode('utf-8').splitlines()

def popup_box(win, title):
    esc_label = "─┤esc├─"
    height, width = win.getmaxyx()
    label_x = width - len(esc_label) - 1
    win.erase()
    win.attron(curses.color_pair(COLOR_PAIR_DARKER))
    win.box()
    win.addstr(0, max(2, (width - len(title)) // 2), f"{title[:width - 4]}", curses.color_pair(COLOR_PAIR_MENU))
    win.addstr(height - 1, label_x, esc_label)
    win.attroff(curses.color_pair(COLOR_PAIR_DARKER))
    win.addstr(height - 1, label_x + 2, "esc", curses.color_pair(COLOR_PAIR_HEADER))

def intro_window(stdscr):
    height, width = stdscr.getmaxyx()
    box_width = 50
    box_height = max(len(get_logo_lines()), 5) + 5
    box_y = (height - box_height) // 2
    box_x = (width - box_width) // 2
    intro_win = curses.newwin(box_height, box_width, box_y, box_x)
    popup_box(intro_win, "")
    curses.noecho()
    title = "Keyzer Chief 0.9b"
    for i in range(len(title)):
        intro_win.addstr(4, 26, title[:i+1], curses.color_pair(COLOR_PAIR_WHITE_DIM) | curses.A_BOLD)
        intro_win.refresh()
        curses.napms(9)
    intro_win.addstr(5, 24, "Java Keystore Manager", curses.color_pair(COLOR_PAIR_CYAN) | curses.A_ITALIC)
    intro_win.addstr(14, 22, "Keystore password:")
    return intro_win

def show_logo(win, final):
    logo_lines = get_logo_lines()
    # Scramble effect before revealing
    if not final:
        temp_lines = [['█' if ch != ' ' else ' ' for ch in line] for line in logo_lines]
        for idx, color in enumerate([236, 58, 100, 136, 178]):
            curses.init_pair(30 + idx, color, -1)
            for i, row in enumerate(temp_lines):
                line = ''.join(random.choice('▓ ▒ ░ ▀') if ch != ' ' else ' ' for ch in row)
                win.addstr(LOGO_Y + i, LOGO_X, line, curses.color_pair(30 + idx) | curses.A_DIM)
            win.refresh()
            curses.napms(35)

    # Final logo render
    for i, line in enumerate(logo_lines):
        win.addstr(LOGO_Y + i, LOGO_X, line, curses.color_pair(COLOR_PAIR_HEADER))
    win.refresh()
    curses.napms(100)

def fade_logo(win):
    logo_lines = get_logo_lines()
    for idx, color in enumerate([220, 178, 136, 100, 58, 236, 234]):
        curses.init_pair(30 + idx, color, -1)
        for i, line in enumerate(logo_lines):
            win.addstr(LOGO_Y + i, LOGO_X, line, curses.color_pair(30 + idx) | curses.A_DIM)
        win.refresh()
        curses.napms(35)
        win.clear()

def shake_logo(win):
    logo_lines = get_logo_lines()
    for shake in [-1, 1, -1, 1, 0]:
        for i, line in enumerate(logo_lines): # Clean previous frame
            win.addstr(LOGO_Y + i, LOGO_X, " " * (len(line)+1))
        win.refresh()
        for i, line in enumerate(logo_lines):
            win.addstr(LOGO_Y + i, LOGO_X + shake, line, curses.color_pair(COLOR_PAIR_EXPIRED_DIM))
        win.refresh()
        curses.napms(35)
    show_logo(win, True)

def draw_footer(stdscr, has_unsaved_changes):
    height, width = stdscr.getmaxyx()
    spacing = width // len(FOOTER_OPTIONS)
    for i, item in enumerate(FOOTER_OPTIONS):
        label = item[2:]
        prefix = item[:2]
        attr_key = curses.color_pair(COLOR_PAIR_SELECTED) if "Save" in label and has_unsaved_changes else curses.color_pair(COLOR_PAIR_FKEYS)
        stdscr.addstr(height - 1, i * spacing, prefix, attr_key)
        stdscr.addstr(height - 1, i * spacing + 2, label.ljust(spacing - 2), curses.color_pair(COLOR_PAIR_HEADER))

def highlight_footer_key(stdscr, key_index):
    height, width = stdscr.getmaxyx()
    spacing = width // len(FOOTER_OPTIONS)
    label = FOOTER_OPTIONS[key_index][2:]
    stdscr.addstr(height - 1, key_index * spacing + 2, label.ljust(spacing - 2), curses.color_pair(COLOR_PAIR_HEADER) | curses.A_BOLD)
    stdscr.refresh()
    time.sleep(0.2) # Keep highlight momentarily
    stdscr.addstr(height - 1, key_index * spacing + 2, label.ljust(spacing - 2), curses.color_pair(COLOR_PAIR_HEADER))

def draw_ui(stdscr, entries, selected, scroll_offset, detail_scroll, active_panel, dim=False):
    height, width = stdscr.getmaxyx()
    panel_width = width // 2
    max_detail_width = width - panel_width - 5
    visible_height = height - 4

    if dim:
        stdscr.attron(curses.A_DIM)
        title_attr = curses.color_pair(COLOR_PAIR_HEADER) | curses.A_DIM
    else:
        stdscr.attroff(curses.A_DIM)
        title_attr = curses.color_pair(COLOR_PAIR_HEADER)

    # Fix scroll offset if needed
    if selected < scroll_offset:
        scroll_offset = selected
    elif selected >= scroll_offset + visible_height:
        scroll_offset = selected - visible_height + 1

    # Draw static borders
    for y in range(2, height - 2):
        stdscr.addch(y, 0, curses.ACS_VLINE)
        stdscr.addch(y, panel_width - 1, curses.ACS_VLINE)
        stdscr.addch(y, panel_width, curses.ACS_VLINE)
        stdscr.addch(y, width - 1, curses.ACS_VLINE)

    stdscr.addch(1, 0, curses.ACS_ULCORNER)
    stdscr.addch(1, panel_width - 1, curses.ACS_URCORNER)
    stdscr.hline(1, 1, curses.ACS_HLINE, panel_width - 2)
    stdscr.addstr(1, panel_width - 7, "─┤")
    stdscr.addstr("t", curses.color_pair(COLOR_PAIR_DARK))
    stdscr.addstr("op├")
    stdscr.addstr(1, 3, f" Keystore: {ORIGINAL_KEYSTORE_PATH} ", title_attr)
    stdscr.addch(height - 2, 0, curses.ACS_LLCORNER)
    stdscr.addch(height - 2, panel_width - 1, curses.ACS_LRCORNER)
    stdscr.hline(height - 2, 1, curses.ACS_HLINE, panel_width - 2)
    stdscr.addstr(height - 2, panel_width - 7, "─┤")
    stdscr.addstr("b", curses.color_pair(COLOR_PAIR_DARK))
    stdscr.addstr("ot├")

    stdscr.addch(1, panel_width, curses.ACS_ULCORNER)
    stdscr.addch(1, width - 1, curses.ACS_URCORNER)
    stdscr.hline(1, panel_width + 1, curses.ACS_HLINE, width - panel_width - 2)
    stdscr.addstr(1, panel_width + 3, " Details ", title_attr)
    stdscr.addch(height - 2, panel_width, curses.ACS_LLCORNER)
    stdscr.addch(height - 2, width - 1, curses.ACS_LRCORNER)
    stdscr.hline(height - 2, panel_width + 1, curses.ACS_HLINE, width - panel_width - 2)

    # Left panel entries
    for i in range(scroll_offset, min(len(entries), scroll_offset + visible_height)):
        y_pos = 2 + i - scroll_offset
        alias = entries[i].get("Alias name", "<unknown>")
        is_expired = entries[i].get("__expired__", False)
        if active_panel == LEFT_PANEL:
            if i == selected:
                if dim:
                    attr = curses.color_pair(COLOR_PAIR_SELECTED_DIM_MORE)
                else:
                    attr = curses.color_pair(COLOR_PAIR_SELECTED)
            elif is_expired:
                attr = curses.color_pair(COLOR_PAIR_EXPIRED)
            else:
                attr = curses.color_pair(COLOR_PAIR_WHITE)
        else:
            if i == selected:
                if dim:
                    attr = curses.color_pair(COLOR_PAIR_SELECTED_DIM_MORE)
                else:
                    attr = curses.color_pair(COLOR_PAIR_SELECTED_DIM)
            elif is_expired:
                attr = curses.color_pair(COLOR_PAIR_EXPIRED_DIM)
            else:
                attr = curses.color_pair(COLOR_PAIR_WHITE_DIM)

        if dim:
            attr |= curses.A_DIM

        stdscr.addstr(y_pos, 2, " " * (panel_width - 4))
        stdscr.addstr(y_pos, 2, alias[:panel_width - 4], attr)

    # Clear remaining left panel rows
    for y in range(2 + len(entries) - scroll_offset, height - 2):
        stdscr.addstr(y, 2, " " * (panel_width - 4))

    # Right panel details
    detail_lines = entries[selected].get("__rendered__", [])[detail_scroll:]
    line_num = 2
    highlight_term = RIGHT_PANEL_HIGHLIGHT_TERM.lower() if RIGHT_PANEL_HIGHLIGHT_TERM else None
    for key, value in detail_lines:
        if line_num >= height - 2:
            break
        lines = [value[i:i+max_detail_width] for i in range(0, len(value), max_detail_width)]
        attr = curses.color_pair(COLOR_PAIR_WHITE if active_panel == RIGHT_PANEL else COLOR_PAIR_WHITE_DIM)
        attrtit = curses.color_pair(COLOR_PAIR_CYAN if active_panel == RIGHT_PANEL else COLOR_PAIR_CYAN_DIM)
        attrexp = curses.color_pair(COLOR_PAIR_EXPIRED if active_panel == RIGHT_PANEL else COLOR_PAIR_EXPIRED_DIM)
        highlight_attr = curses.color_pair(COLOR_PAIR_MENU)

        if dim:
            attr |= curses.A_DIM
            attrtit |= curses.A_DIM
            attrexp |= curses.A_DIM
            highlight_attr |= curses.A_DIM

        stdscr.addstr(line_num, panel_width + 2, " " * (width - panel_width - 3))
        if key == "Valid from" and entries[selected].get("__expired__") == True:
            stdscr.addstr(line_num, panel_width + 2, f"{key}:", curses.A_UNDERLINE | attrexp)
        else:
            stdscr.addstr(line_num, panel_width + 2, f"{key}:", curses.A_UNDERLINE | attrtit)
        line_num += 1
        for l in lines:
            if line_num >= height - 2:
                break
            stdscr.addstr(line_num, panel_width + 2, " " * (width - panel_width - 3))
            if highlight_term and highlight_term in l.lower():
                start = 0
                x = panel_width + 4
                l_lower = l.lower()
                while start < len(l):
                    idx = l_lower.find(highlight_term, start)
                    if idx == -1:
                        stdscr.addstr(line_num, x, l[start:], attr)
                        break
                    if idx > start:
                        stdscr.addstr(line_num, x, l[start:idx], attr)
                        x += idx - start
                    stdscr.addstr(line_num, x, l[idx:idx+len(highlight_term)], highlight_attr)
                    x += len(highlight_term)
                    start = idx + len(highlight_term)
            else:
                stdscr.addstr(line_num, panel_width + 4, l, attr)
            line_num += 1

    # Clear remaining right panel rows
    for y in range(line_num, height - 2):
        stdscr.addstr(y, panel_width + 2, " " * (width - panel_width - 3))

    stdscr.move(0, 0)
    stdscr.refresh()
    return scroll_offset

def main(stdscr):
    init_curses()
    signal.signal(signal.SIGINT, signal.SIG_IGN) # Disable CTRL+C
    global RELOAD_ENTRIES

    intro_win = intro_window(stdscr)
    show_logo(intro_win, False)

    if not check_password(KEYSTORE_PATH, password=""):
        password = prompt_password(intro_win)
    else:
        fade_logo(intro_win)

    RELOAD_ENTRIES = True

    selected = 0
    scroll_offset = 0
    detail_scroll = 0
    active_panel = 0

    has_unsaved_changes = False

    while True:
        height, width = stdscr.getmaxyx()
        panel_height = height - 4  # Subtract top and bottom padding (borders)

        if RELOAD_ENTRIES:
            RELOAD_ENTRIES = False
            entries = get_keystore_entries(KEYSTORE_PATH, password)
            selected = 0

        draw_ui(stdscr, entries, selected, scroll_offset, detail_scroll, active_panel)
        draw_footer(stdscr, has_unsaved_changes)
        draw_menu_bar(None, width)

        key = stdscr.getch()
        if key == curses.KEY_MOUSE:
            try:
                _, mx, my, _, mouse_event = curses.getmouse()

                if my == 0:
                    x = 1
                    for i, item in enumerate(MENU_ITEMS):
                        item_len = len(f" {item} ")
                        if x <= mx < x + item_len:
                            active_menu = i
                            draw_ui(stdscr, entries, selected, scroll_offset, detail_scroll, active_panel, True)
                            menu_modal(stdscr, has_unsaved_changes, active_menu, redraw_main_ui=lambda: draw_ui(stdscr, entries, selected, scroll_offset, detail_scroll, active_panel, True))
                            break
                        x += item_len + 2

                if my == 1 and width // 2 - 6 <= mx < width // 2: # Clicked 'top'
                    selected = 0
                    scroll_offset = 0
                elif my == height - 2 and width // 2 - 6 <= mx < width // 2: # Clicked 'bot'
                    selected = len(entries) - 1
                    scroll_offset = max(0, len(entries) - panel_height)

                if 1 < my < height - 2:
                    if 0 < mx < width // 2:
                        active_panel = LEFT_PANEL
                    elif mx >= width // 2:
                        active_panel = RIGHT_PANEL

                if mouse_event & 0x80000:
                    if active_panel == LEFT_PANEL and selected > 0:
                        selected -= 1
                        if selected < scroll_offset:
                            scroll_offset -= 1
                        detail_scroll = 0
                    elif active_panel == RIGHT_PANEL and detail_scroll > 0:
                        detail_scroll -= 1

                elif mouse_event & 0x8000000:
                    if active_panel == LEFT_PANEL and selected < len(entries) - 1:
                        selected += 1
                        if selected >= scroll_offset + panel_height:
                            scroll_offset += 1
                        detail_scroll = 0
                    elif active_panel == RIGHT_PANEL:
                        detail_scroll += 1

            except curses.error:
                pass

        elif key == curses.KEY_UP:
            if active_panel == LEFT_PANEL:
                if selected > 0:
                    selected -= 1
                    if selected < scroll_offset:
                        scroll_offset -= 1
                detail_scroll = 0
            elif active_panel == RIGHT_PANEL and detail_scroll > 0:
                detail_scroll -= 1

        elif key == curses.KEY_DOWN:
            if active_panel == LEFT_PANEL:
                if selected < len(entries) - 1:
                    selected += 1
                    if selected >= scroll_offset + panel_height:
                        scroll_offset += 1
                detail_scroll = 0
            elif active_panel == RIGHT_PANEL:
                detail_scroll += 1

        elif key == ord('t'):
            if active_panel == LEFT_PANEL:
                selected = 0
                scroll_offset = 0
            else:
                detail_scroll = 0

        elif key == ord('b'):
            if active_panel == LEFT_PANEL:
                selected = len(entries) - 1
                scroll_offset = max(0, len(entries) - panel_height)
            else:
                detail_scroll = max(0, len(entries[selected].get("__rendered__", [])) - 1)

        elif key == ord('\t') or key == 9:
            active_panel = RIGHT_PANEL if active_panel == LEFT_PANEL else LEFT_PANEL

        elif curses.KEY_F1 <= key <= curses.KEY_F10:
            highlight_footer_key(stdscr, (key - curses.KEY_F1))

            if key == curses.KEY_F3:
                draw_ui(stdscr, entries, selected, scroll_offset, detail_scroll, active_panel, True)
                alias = import_cert_file(stdscr, password)
                if alias:
                    entries = get_keystore_entries(KEYSTORE_PATH, password)
                    selected = find_entry_index_by_alias(entries, alias)
                    has_unsaved_changes = check_unsaved_changes()

            elif key == curses.KEY_F4:
                draw_ui(stdscr, entries, selected, scroll_offset, detail_scroll, active_panel, True)
                choice = prompt_import_key_type(stdscr)
                if choice == "PKCS #12":
                    alias = import_pkcs12_keypair(stdscr, KEYSTORE_PATH, password)
                elif choice == "PKCS #8":
                    alias = import_pkcs8_keypair(stdscr, KEYSTORE_PATH, password)
                else:
                    alias = None
                if alias:
                    entries = get_keystore_entries(KEYSTORE_PATH, password)
                    selected = find_entry_index_by_alias(entries, alias)
                    has_unsaved_changes = check_unsaved_changes()

            elif key == curses.KEY_F5:
                draw_ui(stdscr, entries, selected, scroll_offset, detail_scroll, active_panel, True)
                alias = import_cert_from_url(stdscr, password)
                if alias:
                    entries = get_keystore_entries(KEYSTORE_PATH, password)
                    selected = find_entry_index_by_alias(entries, alias)
                    has_unsaved_changes = check_unsaved_changes()

            elif key == curses.KEY_F7:
                draw_ui(stdscr, entries, selected, scroll_offset, detail_scroll, active_panel, True)
                has_unsaved_changes = save_changes(has_unsaved_changes)

            elif key == curses.KEY_F8:
                draw_ui(stdscr, entries, selected, scroll_offset, detail_scroll, active_panel, True)
                has_unsaved_changes = delete_entry(password, entries[selected].get("Alias name"))
                entries = get_keystore_entries(KEYSTORE_PATH, password)
                selected = min(selected, len(entries) - 1)

            elif key == curses.KEY_F9:
                draw_ui(stdscr, entries, selected, scroll_offset, detail_scroll, active_panel, True)
                menu_modal(stdscr, has_unsaved_changes, 0, redraw_main_ui=lambda: draw_ui(stdscr, entries, selected, scroll_offset, detail_scroll, active_panel, True))

            elif key in [curses.KEY_F10, ord('q'), ord('Q'), 27]:
                save_changes(has_unsaved_changes)
                break

        if has_unsaved_changes:
            if selected == len(entries) - 1:
                scroll_offset = max(0, len(entries) - panel_height)

curses.wrapper(main)
