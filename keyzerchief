#!/usr/bin/env python3

import curses
import subprocess
import shutil
import tempfile
import sys
import os
import base64
import gzip
import random
import time
from io import BytesIO
from datetime import datetime
from datetime import datetime, timezone

# Config from argument
if len(sys.argv) < 2:
    print("Usage: keystoreterm <keystore-file>")
    sys.exit(1)

ORIGINAL_KEYSTORE_PATH = sys.argv[1]
if not os.path.isfile(ORIGINAL_KEYSTORE_PATH):
    print(f"File not found: {ORIGINAL_KEYSTORE_PATH}")
    sys.exit(1)

KEYSTORE_COPY_PATH = tempfile.NamedTemporaryFile(delete=False, suffix=".jks").name
KEYSTORE_PATH = KEYSTORE_COPY_PATH
shutil.copyfile(ORIGINAL_KEYSTORE_PATH, KEYSTORE_COPY_PATH)

# Colors
COLOR_PAIR_SELECTED = 1
COLOR_PAIR_HEADER = 2
COLOR_PAIR_MENU = 3
COLOR_PAIR_FKEYS = 4
COLOR_PAIR_ACTIVE = 5
COLOR_PAIR_INACTIVE = 6
COLOR_PAIR_WARN = 7
COLOR_PAIR_DARK = 8
COLOR_PAIR_GREEN = 9
COLOR_PAIR_RED = 10
COLOR_PAIR_EXPIRED = 11
COLOR_PAIR_DARKER = 12

# Mouse support constants
LEFT_PANEL = 0
RIGHT_PANEL = 1

def file_picker(stdscr, start_path="."):
    win_height = 20
    win_width = 70
    curses.curs_set(0)
    current_path = os.path.abspath(start_path)
    selected_index = 0
    scroll_offset = 0

    while True:
        stdscr.clear()
        height, width = stdscr.getmaxyx()

        # Create centered window
        start_y = (height - win_height) // 2
        start_x = (width - win_width) // 2
        win = curses.newwin(win_height, win_width, start_y, start_x)
        win.keypad(True)
        popup_box(win)

        try:
            entries = os.listdir(current_path)
            entries.sort()
            entries = [".."] + entries
        except PermissionError:
            entries = [".."]

        visible_height = win_height - 3  # account for header
        visible_entries = entries[scroll_offset:scroll_offset + visible_height]

        if selected_index >= len(entries):
            selected_index = len(entries) - 1

        title = f" Select a file: {current_path} "
        win.addstr(0, max(2, (win_width - len(title)) // 2), title[:win_width - 4], curses.color_pair(COLOR_PAIR_MENU))
        win.addstr(1, 1, f" {'Name':<35} {'Size':>9} {'Modified':>20}", curses.A_BOLD)

        for idx, entry in enumerate(visible_entries):
            actual_index = scroll_offset + idx
            entry_path = os.path.join(current_path, entries[actual_index])
            is_dir = os.path.isdir(entry_path)
            is_cert = entry_path.endswith(('.crt', '.cer', '.pem'))
            is_key = entry_path.endswith(('.key', '.p12', '.pfx', '.jks'))
            is_selected = actual_index == selected_index

            try:
                size = os.path.getsize(entry_path)
                mtime = time.strftime('%Y-%m-%d %H:%M', time.localtime(os.path.getmtime(entry_path)))
            except Exception:
                size = 0
                mtime = ""

            size_str = f"{size:,}" if not is_dir else "<DIR>"
            name_str = f"{entry}/" if is_dir else entry
            if is_selected:
                attr = curses.color_pair(COLOR_PAIR_SELECTED)
            elif is_cert:
                attr = curses.color_pair(COLOR_PAIR_HEADER)
            elif is_key:
                attr = curses.color_pair(COLOR_PAIR_EXPIRED)
            else:
                attr = curses.A_NORMAL

            win.addstr(idx + 2, 1, f" {name_str:<35.35} {size_str:>9} {mtime:>20}", attr)

        key = win.getch()

        if key in [curses.KEY_UP, ord("k")]:
            if selected_index > 0:
                selected_index -= 1
        elif key in [curses.KEY_DOWN, ord("j")]:
            if selected_index < len(entries) - 1:
                selected_index += 1
        elif key in [10, 13]:
            selected_entry = entries[selected_index]
            full_path = os.path.join(current_path, selected_entry)
            if os.path.isdir(full_path):
                current_path = os.path.abspath(full_path)
                selected_index = 0
                scroll_offset = 0
            else:
                win.clear()
                win.refresh()
                return os.path.abspath(full_path)
        elif key in [27, ord("q")]:
            win.clear()
            win.refresh()
            return None

        if selected_index < scroll_offset:
            scroll_offset = selected_index
        elif selected_index >= scroll_offset + visible_height:
            scroll_offset = selected_index - visible_height + 1

        win.erase()
        win.refresh()

def prompt_import_pkcs12_form(stdscr):
    title = " Import PKCS #12 Key Pair "
    height, width = stdscr.getmaxyx()
    win_width = 60
    win_height = 10
    start_y = (height - win_height) // 2
    start_x = (width - win_width) // 2

    win = curses.newwin(win_height, win_width, start_y, start_x)
    win.keypad(True)

    labels = ["Key pair file:", "Decryption password:"]
    values = ["", ""]
    field_count = len(labels)
    current = 0
    selected_button = 0
    in_buttons = False

    while True:
        win.attron(curses.color_pair(COLOR_PAIR_EXPIRED))
        popup_box(win)
        win.addstr(0, max(2, (win_width - len(title)) // 2), title[:win_width - 4], curses.color_pair(COLOR_PAIR_MENU))
        for i, label in enumerate(labels):
            win.addstr(3 + i, 2, label)
            attr = curses.A_REVERSE if (not in_buttons and i == current) else curses.A_NORMAL
            display_value = values[i] if i == 0 else '*' * len(values[i])
            win.addstr(3 + i, len(label) + 3, display_value.ljust(win_width - len(label) - 5), attr)

        # Clear the button row
        win.addstr(7, 2, " " * (win_width - 4))

        import_attr = curses.A_REVERSE if in_buttons and selected_button == 0 else curses.A_NORMAL
        cancel_attr = curses.A_REVERSE if in_buttons and selected_button == 1 else curses.A_NORMAL

        win.addstr(8, 2, "[", curses.A_BOLD)
        win.addstr(" Import ", import_attr | curses.A_BOLD)
        win.addstr("]   [", curses.A_BOLD)
        win.addstr(" Cancel ", cancel_attr | curses.A_BOLD)
        win.addstr("]", curses.A_BOLD)

        if not in_buttons:
            cursor_x = 22 + len(display_value)
            win.move(3 + current, cursor_x)

        win.refresh()
        key = win.getch()

        if not in_buttons:
            if key == curses.KEY_UP and current > 0:
                current -= 1
            elif key == curses.KEY_DOWN:
                if current < field_count - 1:
                    current += 1
                else:
                    in_buttons = True
                    selected_button = 0
            elif key in [curses.KEY_BACKSPACE, 127, 8]:
                if values[current]:
                    values[current] = values[current][:-1]
            elif 32 <= key <= 126:
                if len(values[current]) < 30:
                    values[current] += chr(key)
            elif key in [10, 13]:
                if current == 0:
                    file_path = file_picker(stdscr)
                    if file_path:
                        values[0] = file_path
        else:
            if key in [curses.KEY_LEFT, curses.KEY_RIGHT]:
                selected_button = 1 - selected_button
            elif key in [10, 13]:
                if selected_button == 0 and all(values):
                    curses.noecho()
                    return {
                        "key_file": values[0].strip(),
                        "password": values[1].strip()
                    }
                else:
                    return None
            elif key == curses.KEY_UP:
                in_buttons = False

        if key == 27:
            return None

def import_pkcs12_keypair(stdscr, keystore_path, keystore_pass, key_file, key_pass):
    stdscr.clear()
    stdscr.addstr(0, 2, "Importing key pair...", curses.A_BOLD)
    stdscr.refresh()

    alias = os.path.splitext(os.path.basename(key_file))[0]
    cmd = [
        "keytool", "-importkeystore",
        "-srckeystore", key_file,
        "-srcstoretype", "PKCS12",
        "-destkeystore", keystore_path,
        "-deststorepass", keystore_pass,
        "-srcstorepass", key_pass,
        "-alias", alias,
        "-destalias", alias
    ]
    result = subprocess.run(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
    stdscr.clear()
    if result.returncode == 0:
        stdscr.addstr(2, 2, f"Successfully imported: {alias}", curses.A_BOLD)
        return alias
    else:
        stdscr.addstr(2, 2, "Import failed:", curses.A_BOLD)
        stdscr.addstr(4, 2, result.stderr.strip())
    stdscr.addstr(6, 2, "Press any key to continue.")
    stdscr.refresh()
    stdscr.getch()

def import_pkcs8_keypair(stdscr, keystore_path, keystore_pass, form_data):
    alias = os.path.splitext(os.path.basename(form_data['key_file']))[0]

    pkcs8_cmd = [
        "openssl", "pkcs8",
        "-topk8",
        "-inform", "PEM",
        "-outform", "PEM",
        "-in", form_data['key_file'],
        "-passin", f"pass:{form_data['password']}" if form_data['encrypted'] else "pass:",
        "-out", "/tmp/converted_pkcs8.key"
    ]

    cmd = [
        "keytool", "-importcert",
        "-keystore", keystore_path,
        "-storepass", keystore_pass,
        "-alias", alias,
        "-file", form_data['cert_file'],
        "-keypass", form_data['password'] if form_data['encrypted'] else keystore_pass
    ]

    # Run OpenSSL to convert key
    openssl_result = subprocess.run(pkcs8_cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
    stdscr.clear()
    if openssl_result.returncode != 0:
        stdscr.addstr(0, 2, "OpenSSL conversion failed:", curses.A_BOLD)
        stdscr.addstr(2, 2, openssl_result.stderr.strip())
    else:
        keytool_result = subprocess.run(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
        if keytool_result.returncode == 0:
            stdscr.addstr(0, 2, f"Successfully imported: {alias}", curses.A_BOLD)
            return alias
        else:
            stdscr.addstr(0, 2, "Import failed:", curses.A_BOLD)
            stdscr.addstr(2, 2, keytool_result.stderr.strip())
    stdscr.addstr(4, 2, "Press any key to continue.")
    stdscr.refresh()
    stdscr.getch()

def prompt_import_pkcs8_form(stdscr):
    title = " Import PKCS #8 Key Pair "
    height, width = stdscr.getmaxyx()
    win_width = 70
    win_height = 13
    start_y = (height - win_height) // 2
    start_x = (width - win_width) // 2

    win = curses.newwin(win_height, win_width, start_y, start_x)
    win.keypad(True)

    encrypted = True
    labels = ["Certificates file:", "PKCS#8 key file:", "Decryption password:"]
    values = ["", "", ""]
    current = -2
    selected_button = 0
    in_buttons = False

    while True:
        popup_box(win)
        win.addstr(0, max(2, (win_width - len(title)) // 2), title[:win_width - 4], curses.color_pair(COLOR_PAIR_MENU))
        win.addstr(3, 2, "Encrypted Private Key:")
        yes_attr = curses.color_pair(COLOR_PAIR_MENU) if encrypted else curses.A_NORMAL
        no_attr = curses.color_pair(COLOR_PAIR_MENU) if not encrypted else curses.A_NORMAL
        if current == -2:
            yes_attr |= curses.A_BOLD
            no_attr |= curses.A_BOLD
        win.addstr(3, 26, " Yes ", yes_attr)
        win.addstr(3, 33, " No ", no_attr)

        field_index = 0
        for i, label in enumerate(labels):
            y_pos = 5 + i
            if not encrypted and i == 2:
                win.move(y_pos, 2)
                win.addstr(y_pos, 2, " " * (win_width - 4))
                continue
            else:
                win.addstr(y_pos, 2, label)

            field_index = i
            is_selected = (not in_buttons and current == field_index)
            attr = curses.A_REVERSE if is_selected else curses.A_NORMAL

            if i == 2:
                display_value = '*' * len(values[i])
            else:
                display_value = values[i]

            win.addstr(y_pos, len(label) + 3, display_value.ljust(win_width - len(label) - 5), attr)

        win.addstr(11, 2, " " * (win_width - 4))
        import_attr = curses.A_REVERSE if in_buttons and selected_button == 0 else curses.A_NORMAL
        cancel_attr = curses.A_REVERSE if in_buttons and selected_button == 1 else curses.A_NORMAL

        win.addstr(11, 2, "[", curses.A_BOLD)
        win.addstr(" Import ", import_attr | curses.A_BOLD)
        win.addstr("]   [", curses.A_BOLD)
        win.addstr(" Cancel ", cancel_attr | curses.A_BOLD)
        win.addstr("]", curses.A_BOLD)

        if not in_buttons:
            if current >= 0:
                y_cursor = 5 + current
                x_cursor = 26 + len(values[current])
                win.move(y_cursor, x_cursor)

        win.refresh()
        key = win.getch()

        if current == -2:
            if key in [10, 13]:
                encrypted = not encrypted
            elif key == curses.KEY_LEFT:
                encrypted = True
            elif key == curses.KEY_RIGHT:
                encrypted = False
            elif key == curses.KEY_DOWN:
                current = 0
        elif not in_buttons:
            field_count = 3 if encrypted else 2
            if key == curses.KEY_UP:
                if current > 0:
                    current -= 1
                else:
                    current = -2
            elif key == curses.KEY_DOWN:
                if current < field_count - 1:
                    current += 1
                else:
                    in_buttons = True
                    selected_button = 0
            elif key in [curses.KEY_BACKSPACE, 127, 8]:
                if values[current]:
                    values[current] = values[current][:-1]
            elif 32 <= key <= 126:
                if len(values[current]) < 60:
                    values[current] += chr(key)
            elif key in [10, 13]:
                if current == 0:
                    file_path = file_picker(stdscr)
                    if file_path:
                        values[0] = file_path
                if current == 1:
                    file_path = file_picker(stdscr)
                    if file_path:
                        values[1] = file_path
        else:
            if key in [curses.KEY_LEFT, curses.KEY_RIGHT]:
                selected_button = 1 - selected_button
            elif key in [10, 13]:
                if selected_button == 0:
                    curses.noecho()
                    return {
                        "encrypted": encrypted,
                        "key_file": values[0].strip(),
                        "cert_file": values[1].strip(),
                        "password": values[2].strip(),
                    }
                else:
                    return None
            elif key == curses.KEY_UP:
                in_buttons = False

        if key == 27:
            return None

def prompt_import_key_type(stdscr):
    key_types = ["PKCS #12", "PKCS #8", "PVK", "OpenSSL"]
    height, width = stdscr.getmaxyx()
    win_height = len(key_types) + 5
    win_width = max(len(t) for t in key_types) + 13
    win = curses.newwin(win_height, win_width, (height - win_height) // 2, (width - win_width) // 2)
    win.keypad(True)
    popup_box(win)
    win.addstr(1, 3, "Import Key Pair", curses.color_pair(COLOR_PAIR_HEADER))
    selected = 0

    while True:
        for i, option in enumerate(key_types):
            mode = curses.A_REVERSE if i == selected else curses.A_NORMAL
            win.addstr(3 + i, 4, option.ljust(win_width - 8), mode)
        win.refresh()
        key = win.getch()
        if key == curses.KEY_UP and selected > 0:
            selected -= 1
        elif key == curses.KEY_DOWN and selected < len(key_types) - 1:
            selected += 1
        elif key in [10, 13]:
            return key_types[selected]
        elif key in [27]:
            return None

def import_cert_file(stdscr, password):
    title = " Import Certificate File "
    height, width = stdscr.getmaxyx()
    win_width = 60
    win_height = 9
    start_y = (height - win_height) // 2
    start_x = (width - win_width) // 2

    win = curses.newwin(win_height, win_width, start_y, start_x)
    win.keypad(True)
    label = "Certificate file:"
    value = ""
    selected_button = 0
    in_buttons = False

    while True:
        popup_box(win)
        win.addstr(0, max(2, (win_width - len(title)) // 2), title[:win_width - 4], curses.color_pair(COLOR_PAIR_MENU))
        win.addstr(3, 2, label)
        attr = curses.A_REVERSE if not in_buttons else curses.A_NORMAL
        win.addstr(3, 20, value[-38:].ljust(38), attr)

        win.addstr(5, 2, " " * (win_width - 4))
        import_attr = curses.A_REVERSE if in_buttons and selected_button == 0 else curses.A_NORMAL
        cancel_attr = curses.A_REVERSE if in_buttons and selected_button == 1 else curses.A_NORMAL

        win.addstr(7, 2, "[", curses.A_BOLD)
        win.addstr(" Import ", import_attr | curses.A_BOLD)
        win.addstr("]   [", curses.A_BOLD)
        win.addstr(" Cancel ", cancel_attr | curses.A_BOLD)
        win.addstr("]", curses.A_BOLD)

        if not in_buttons:
            win.move(3, 20 + len(value))

        win.refresh()
        key = win.getch()

        if not in_buttons:
            if key in [10, 13]:
                file_path = file_picker(stdscr)
                if file_path:
                    value = file_path
            elif key == curses.KEY_DOWN:
                in_buttons = True
                selected_button = 0
            elif key in [curses.KEY_BACKSPACE, 127, 8]:
                value = value[:-1]
            elif 32 <= key <= 126:
                if len(value) < 60:
                    value += chr(key)
        else:
            if key in [curses.KEY_LEFT, curses.KEY_RIGHT]:
                selected_button = 1 - selected_button
            elif key in [10, 13]:
                if selected_button == 0 and value.strip() and os.path.isfile(value.strip()):
                    cert_file = value.strip()
                    alias = os.path.splitext(os.path.basename(cert_file))[0]
                    import_cmd = [
                        "keytool", "-importcert",
                        "-alias", alias,
                        "-keystore", KEYSTORE_PATH,
                        "-storepass", password,
                        "-file", cert_file,
                        "-noprompt"
                    ]
                    win.clear()
                    popup_box(win)
                    win.addstr(2, 2, f"Importing {cert_file}...", curses.A_BOLD)
                    win.refresh()
                    result = subprocess.run(import_cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
                    if result.returncode == 0:
                        win.addstr(4, 2, f"Successfully imported: {alias}", curses.A_BOLD)
                        win.addstr(6, 2, "Press any key to continue.")
                        win.refresh()
                        win.getch()
                        return alias
                    else:
                        win.addstr(4, 2, "Import failed:", curses.A_BOLD)
                        win.addstr(6, 2, result.stderr.strip())
                        win.addstr(8, 2, "Press any key to continue.")
                        win.refresh()
                        win.getch()
                        return None
                else:
                    return None
            elif key == curses.KEY_UP:
                in_buttons = False
        if key == 27:
            return None

def import_cert_from_url(stdscr, password):
    url = prompt_url_input(stdscr)
    if not url:
        return None

    title = "Import SSL Certificate from URL"
    height, width = stdscr.getmaxyx()
    win_width = 60
    win_height = 9
    start_y = (height - win_height) // 2
    start_x = (width - win_width) // 2
    win = curses.newwin(win_height, win_width, start_y, start_x)
    popup_box(win)
    win.addstr(0, max(2, (win_width - len(title)) // 2), title[:win_width - 4], curses.color_pair(COLOR_PAIR_MENU))
    win.addstr(2, 2, f"Fetching certificate from {url}...")
    win.refresh()

    try:
        if url.startswith("https://") or url.startswith("http://"):
            url = url.split("://", 1)[1]

        parts = url.split(":")
        host = parts[0]
        port = parts[1] if len(parts) > 1 else "443"

        cert_path = f"/tmp/cert_from_{url.replace(':', '_').replace('/', '_')}.crt"
        cmd = [
            "openssl", "s_client", "-showcerts",
            "-servername", host,
            "-connect", f"{host}:{port}"
        ]
        fetch = subprocess.run(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.DEVNULL, text=True, timeout=5)
        start = fetch.stdout.find("-----BEGIN CERTIFICATE-----")
        end = fetch.stdout.find("-----END CERTIFICATE-----") + len("-----END CERTIFICATE-----")
        cert = fetch.stdout[start:end]

        if "-----BEGIN CERTIFICATE-----" not in cert:
            raise Exception("Could not extract certificate")

        with open(cert_path, "w") as f:
            f.write(cert)

        alias = host
        import_cmd = [
            "keytool", "-importcert",
            "-alias", alias,
            "-keystore", KEYSTORE_PATH,
            "-storepass", password,
            "-file", cert_path,
            "-noprompt"
        ]
        result = subprocess.run(import_cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
        win.erase()
        popup_box(win)
        win.addstr(0, max(2, (win_width - len(title)) // 2), title[:win_width - 4], curses.color_pair(COLOR_PAIR_MENU))
        if result.returncode == 0:
            win.addstr(2, 2, f"Successfully imported cert from {url}", curses.A_BOLD)
        else:
            win.addstr(2, 2, "Import failed:", curses.A_BOLD)
            win.addstr(3, 2, result.stderr.strip()[:win_width - 4])
    except Exception as e:
        win.clear()
        popup_box(win)
        win.addstr(2, 2, f"Error: {str(e)}", curses.A_BOLD)

    win.addstr(win_height - 4, 2, "Press any key to continue.")
    win.refresh()
    win.getch()
    return alias if 'alias' in locals() else None

def prompt_url_input(stdscr):
    title = "Import SSL Certificate from URL"
    curses.noecho()
    curses.curs_set(0)
    height, width = stdscr.getmaxyx()
    win_width = 60
    win_height = 9
    start_y = (height - win_height) // 2
    start_x = (width - win_width) // 2

    win = curses.newwin(win_height, win_width, start_y, start_x)
    popup_box(win)
    win.keypad(True)
    value = ""
    selected_button = 0
    in_buttons = False

    while True:
        popup_box(win)
        win.addstr(0, max(2, (win_width - len(title)) // 2), title[:win_width - 4], curses.color_pair(COLOR_PAIR_MENU))
        win.addstr(3, 2, "Hostname:Port (e.g. example.com:443):")
        attr = curses.A_REVERSE if not in_buttons else curses.A_NORMAL
        win.addstr(4, 2, value[-40:].ljust(win_width-4), attr)

        win.addstr(5, 2, " " * (win_width - 4))
        import_attr = curses.A_REVERSE if in_buttons and selected_button == 0 else curses.A_NORMAL
        cancel_attr = curses.A_REVERSE if in_buttons and selected_button == 1 else curses.A_NORMAL

        win.addstr(7, 2, "[", curses.A_BOLD)
        win.addstr(" Import ", import_attr | curses.A_BOLD)
        win.addstr("]   [", curses.A_BOLD)
        win.addstr(" Cancel ", cancel_attr | curses.A_BOLD)
        win.addstr("]", curses.A_BOLD)

        win.refresh()
        key = win.getch()

        if not in_buttons:
            if key == curses.KEY_DOWN:
                in_buttons = True
                selected_button = 0
            elif key in [10, 13]:
                return value.strip() if value else None
            elif key in [curses.KEY_BACKSPACE, 127, 8]:
                value = value[:-1]
            elif 32 <= key <= 126:
                if len(value) < 60:
                    value += chr(key)
        else:
            if key in [curses.KEY_LEFT, curses.KEY_RIGHT]:
                selected_button = 1 - selected_button
            elif key in [10, 13]:
                if selected_button == 0 and value.strip():
                    return value.strip() if value else None
                else:
                    return None
            elif key == curses.KEY_UP:
                in_buttons = False
        if key == 27:
            return None

def delete_entry(password, alias):
    title = "Delete entry?"
    confirm_height, confirm_width = 8, 60
    confirm_y = (curses.LINES - confirm_height) // 2
    confirm_x = (curses.COLS - confirm_width) // 2
    confirm_win = curses.newwin(confirm_height, confirm_width, confirm_y, confirm_x)
    confirm_win.keypad(True)
    popup_box(confirm_win)
    confirm_win.addstr(0, max(2, (confirm_width - len(title)) // 2), title[:confirm_width - 4], curses.color_pair(COLOR_PAIR_MENU))
    confirm_win.addstr(2, 2, f"Entry will be deleted:")
    confirm_win.addstr(3, 2, f"{alias} ", curses.A_BOLD)
    options = ["Yes", "No"]
    selected_option = 1
    while True:
        for i, label in enumerate(options):
            attr = curses.A_REVERSE if i == selected_option else curses.A_NORMAL
            confirm_win.addstr(6, 2 + i * 10, f" {label} ", attr)
        confirm_win.refresh()
        ch = confirm_win.getch()
        if ch in [curses.KEY_LEFT, curses.KEY_RIGHT]:
            selected_option = 1 - selected_option
        elif ch in [10, 13]:
            if selected_option == 0:
                delete_cmd = ["keytool", "-delete", "-alias", alias, "-keystore", KEYSTORE_PATH, "-storepass", password]
                result = subprocess.run(delete_cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
                if result.returncode == 0:
                    return check_unsaved_changes()
                else:
                    confirm_win.erase()
                    confirm_win.addstr(0, 2, "Deletion failed:", curses.A_BOLD)
                    confirm_win.addstr(2, 2, result.stderr.strip())
                    confirm_win.refresh()
                    confirm_win.getch()
            return False
        elif ch in [27]:
            return False

def check_password(keystore_path, password):
    try:
        subprocess.run(
            ["keytool", "-list", "-keystore", keystore_path, "-storepass", password],
            check=True,
            stdout=subprocess.DEVNULL,
            stderr=subprocess.DEVNULL
        )
        return True
    except subprocess.CalledProcessError:
        return False

def check_unsaved_changes():
    try:
        with open(ORIGINAL_KEYSTORE_PATH, 'rb') as f1, open(KEYSTORE_PATH, 'rb') as f2:
            return f1.read() != f2.read()
    except Exception:
        return True

def save_changes(has_unsaved_changes):
    if not has_unsaved_changes:
        return False

    title = "Save changes?"
    confirm_height, confirm_width = 7, 50
    confirm_y = (curses.LINES - confirm_height) // 2
    confirm_x = (curses.COLS - confirm_width) // 2
    confirm_win = curses.newwin(confirm_height, confirm_width, confirm_y, confirm_x)
    confirm_win.keypad(True)
    popup_box(confirm_win)
    confirm_win.addstr(0, max(2, (confirm_width - len(title)) // 2), title[:confirm_width - 4], curses.color_pair(COLOR_PAIR_MENU))
    confirm_win.addstr(2, 2, "Overwrite the original keystore?")

    options = ["Yes", "No"]
    selected_option = 1

    while True:
        for i, label in enumerate(options):
            attr = curses.A_REVERSE if i == selected_option else curses.A_NORMAL
            confirm_win.addstr(5, 2 + i * 10, f" {label} ", attr)
        confirm_win.refresh()
        ch = confirm_win.getch()
        if ch in [curses.KEY_LEFT, curses.KEY_RIGHT]:
            selected_option = (selected_option + 1) % len(options)
        elif ch in [10, 13]:
            if selected_option == 0:
                shutil.copyfile(KEYSTORE_PATH, ORIGINAL_KEYSTORE_PATH)
                confirm_win.addstr(5, 2, "Saving:")
                for i in range(30):
                    confirm_win.addstr(5, 10 + i, "█")
                    confirm_win.refresh()
                    curses.napms(20)
                return False
            return True
        elif ch in [27]:
            return True

def get_keystore_entries(path, password):
    cmd = ["keytool", "-list", "-v", "-keystore", path, "-storepass", password]
    result = subprocess.run(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
    if result.returncode != 0:
        raise Exception("Failed to load keystore:\n" + result.stderr)

    entries = []
    current_entry = {}
    lines = result.stdout.splitlines()[4:]  # Skip first 4 lines
    for line in lines:
        line = line.strip()
        if line.startswith("Alias name:"):
            if current_entry:
                entries.append(current_entry)
            current_entry = {"Alias name": line.split("Alias name:")[1].strip()}
        elif ":" in line:
            key, value = map(str.strip, line.split(":", 1))
            current_entry[key] = value
    if current_entry:
        entries.append(current_entry)

    # Pre-render each entry's details into strings
    for entry in entries:
        detail_lines = []
        priority = ["Alias name", "Entry type", "Creation date", "Valid from"]
        keys = priority + [k for k in entry if k not in priority]
        for key in keys:
            value = entry.get(key, "")
            detail_lines.append((key, value))
        entry["__rendered__"] = detail_lines

        # Detect expiration
        valid_from = entry.get("Valid from")
        if valid_from and "until:" in valid_from:
            try:
                until_str = valid_from.split("until:")[1].strip()
                until_str_clean = until_str.replace("WET", "+0000")
                until_date = datetime.strptime(until_str_clean, "%a %b %d %H:%M:%S %z %Y")
                entry["__expired__"] = until_date < datetime.now(timezone.utc)
            except Exception:
                entry["__expired__"] = False
        else:
            entry["__expired__"] = False

    return entries

def find_entry_index_by_alias(entries, alias):
    for i, entry in enumerate(entries):
        if entry.get("Alias name") == alias:
            return i
    return 0

def draw_ui(stdscr, entries, selected, scroll_offset, detail_scroll, active_panel, has_unsaved_changes):
    height, width = stdscr.getmaxyx()
    panel_width = width // 2
    max_detail_width = width - panel_width - 5
    visible_height = height - 4

    # Fix scroll offset if needed
    if selected < scroll_offset:
        scroll_offset = selected
    elif selected >= scroll_offset + visible_height:
        scroll_offset = selected - visible_height + 1

    # Redraw header (menu)
    stdscr.attron(curses.color_pair(COLOR_PAIR_MENU))
    stdscr.addstr(0, 0, " " * width)
    stdscr.addstr(0, 1, " Left      File      Options      Right ")
    stdscr.attroff(curses.color_pair(COLOR_PAIR_MENU))

    # Draw static borders
    for y in range(2, height - 2):
        stdscr.addch(y, 0, curses.ACS_VLINE)
        stdscr.addch(y, panel_width - 1, curses.ACS_VLINE)
        stdscr.addch(y, panel_width, curses.ACS_VLINE)
        stdscr.addch(y, width - 1, curses.ACS_VLINE)

    stdscr.addch(1, 0, curses.ACS_ULCORNER)
    stdscr.addch(1, panel_width - 1, curses.ACS_URCORNER)
    stdscr.hline(1, 1, curses.ACS_HLINE, panel_width - 2)
    stdscr.addstr(1, panel_width - 7, "─┤")
    stdscr.addstr("t", curses.color_pair(COLOR_PAIR_DARK))
    stdscr.addstr("op├")
    stdscr.addstr(1, 3, f" Keystore: {ORIGINAL_KEYSTORE_PATH} ", curses.color_pair(COLOR_PAIR_HEADER))

    stdscr.addch(height - 2, 0, curses.ACS_LLCORNER)
    stdscr.addch(height - 2, panel_width - 1, curses.ACS_LRCORNER)
    stdscr.hline(height - 2, 1, curses.ACS_HLINE, panel_width - 2)
    stdscr.addstr(height - 2, panel_width - 7, "─┤")
    stdscr.addstr("b", curses.color_pair(COLOR_PAIR_DARK))
    stdscr.addstr("ot├")

    stdscr.addch(1, panel_width, curses.ACS_ULCORNER)
    stdscr.addch(1, width - 1, curses.ACS_URCORNER)
    stdscr.hline(1, panel_width + 1, curses.ACS_HLINE, width - panel_width - 2)
    stdscr.addstr(1, panel_width + 3, " Details ", curses.color_pair(COLOR_PAIR_HEADER))
    stdscr.addch(height - 2, panel_width, curses.ACS_LLCORNER)
    stdscr.addch(height - 2, width - 1, curses.ACS_LRCORNER)
    stdscr.hline(height - 2, panel_width + 1, curses.ACS_HLINE, width - panel_width - 2)

    # Left panel entries
    for i in range(scroll_offset, min(len(entries), scroll_offset + visible_height)):
        y_pos = 2 + i - scroll_offset
        alias = entries[i].get("Alias name", "<unknown>")
        is_expired = entries[i].get("__expired__", False)
        if active_panel == LEFT_PANEL:
            if i == selected:
                attr = curses.color_pair(COLOR_PAIR_SELECTED)
            elif is_expired:
                attr = curses.color_pair(COLOR_PAIR_EXPIRED)
            else:
                attr = curses.color_pair(COLOR_PAIR_ACTIVE)
        else:
            attr = curses.color_pair(COLOR_PAIR_INACTIVE)
        stdscr.move(y_pos, 1)
        stdscr.clrtoeol()
        stdscr.addstr(y_pos, 2, alias[:panel_width - 4], attr)

    # Clear remaining left panel rows
    for y in range(2 + len(entries) - scroll_offset, height - 2):
        stdscr.move(y, 1)
        stdscr.clrtoeol()

    # Right panel details
    detail_lines = entries[selected].get("__rendered__", [])[detail_scroll:]
    line_num = 2
    for key, value in detail_lines:
        if line_num >= height - 2:
            break
        lines = [value[i:i+max_detail_width] for i in range(0, len(value), max_detail_width)]
        attr = curses.color_pair(COLOR_PAIR_ACTIVE if active_panel == RIGHT_PANEL else COLOR_PAIR_INACTIVE)

        stdscr.addstr(line_num, panel_width + 2, " " * (width - panel_width - 3))
        if key == "Valid from" and entries[selected].get("__expired__") == True:
            stdscr.addstr(line_num, panel_width + 2, f"{key}:", curses.A_UNDERLINE | curses.color_pair(COLOR_PAIR_EXPIRED))
        else:
            stdscr.addstr(line_num, panel_width + 2, f"{key}:", curses.A_UNDERLINE | attr)
        line_num += 1
        for l in lines:
            if line_num >= height - 2:
                break
            stdscr.addstr(line_num, panel_width + 4, " " * (width - panel_width - 5))
            stdscr.addstr(line_num, panel_width + 4, l, attr)
            line_num += 1

    # Clear remaining right panel rows
    for y in range(line_num, height - 2):
        stdscr.addstr(y, panel_width + 2, " " * (width - panel_width - 3))

    # Restore  vertical lines that may have been cleared
    for y in range(2, height - 2):
        stdscr.addch(y, panel_width - 1, curses.ACS_VLINE)
        stdscr.addch(y, panel_width, curses.ACS_VLINE)
        stdscr.addch(y, panel_width * 2, curses.ACS_VLINE)

    # Footer
    footer_options = [" 1Help", " 2GenKeyPair", " 3ImpCert", " 4ImpKeyPair", " 5ImpFromWeb", " 6SetPwd", " 7Save", " 8Delete", " 9PullDn", "10Quit"]
    spacing = width // len(footer_options)
    for i, item in enumerate(footer_options):
        label = item[2:]
        prefix = item[:2]
        attr_key = curses.color_pair(COLOR_PAIR_SELECTED) if "Save" in label and has_unsaved_changes else curses.color_pair(COLOR_PAIR_FKEYS)
        attr_label = curses.color_pair(COLOR_PAIR_HEADER) | curses.A_BOLD if "Save" in label and has_unsaved_changes else curses.color_pair(COLOR_PAIR_HEADER)
        stdscr.addstr(height - 1, i * spacing, prefix, attr_key)
        stdscr.addstr(height - 1, i * spacing + 2, label.ljust(spacing - 2), attr_label)

    stdscr.move(0, 0)
    stdscr.refresh()
    return scroll_offset

def prompt_password(win):
    win_y, win_x = win.getbegyx()
    while True:
        curses.noecho()
        title = "Keyzer Chief 0.9b"
        for i in range(len(title)):
            win.addstr(4, 26, title[:i+1], curses.color_pair(COLOR_PAIR_INACTIVE) | curses.A_BOLD)
            win.refresh()
            curses.napms(30)
        win.addstr(5, 24, "Java Keystore Manager", curses.color_pair(COLOR_PAIR_EXPIRED))
        win.addstr(14, 22, "Keystore password:")
        keypad_win = curses.newwin(1, 25, win_y + 15, win_x + 22)
        keypad_win.addstr(0, 0, " " * 24, curses.color_pair(COLOR_PAIR_FKEYS))
        keypad_win.keypad(True)
        keypad_win.move(0,0)
        win.refresh()
        curses.curs_set(1)
        password = ""

        while True:
            ch = keypad_win.getch()
            if ch in [10, 13]:  # Enter
                if not check_password(KEYSTORE_PATH, password):
                    curses.curs_set(0)
                    password = ""
                    shake_logo(win)
                    keypad_win.clear()
                    keypad_win.addstr(0, 0, " " * 24, curses.color_pair(COLOR_PAIR_FKEYS))
                    keypad_win.move(0,0)
                    curses.curs_set(1)
                else:
                    fade_logo(win)
                    curses.curs_set(0)
                    return password
            elif ch in [27]:  # ESC
                curses.curs_set(0)
                fade_logo(win)
                exit(1)
            elif ch in [curses.KEY_BACKSPACE, 127, 8]:
                if len(password) > 0:
                    password = password[:-1]
                    keypad_win.addch(0, len(password), ' ', curses.color_pair(COLOR_PAIR_FKEYS))
                    keypad_win.move(0, len(password))
            elif 32 <= ch <= 126:
                if len(password)+1 > 24:
                    break
                if len(password) < 30:
                    password += chr(ch)
                    keypad_win.addch(0, len(password) - 1, '*', curses.color_pair(COLOR_PAIR_FKEYS))

def get_logo_lines():
    ascii_art_base64 = 'H4sICJNV/WcAA2tleS1hbnNpLmFucwDjUgCCR9M6cCEuVFkFdOVc6JoxVGBThB/RWjleDyMU4VAGl0IPCDRhbOpoqAguBnc3FwAUPk4X3AEAAA=='
    compressed_data = base64.b64decode(ascii_art_base64)
    with gzip.GzipFile(fileobj=BytesIO(compressed_data)) as f:
        return f.read().decode('utf-8').splitlines()

def popup_box(win):
    esc_label = "─┤esc├─"
    height, width = win.getmaxyx()
    label_x = width - len(esc_label) - 1
    win.attron(curses.color_pair(COLOR_PAIR_DARKER))
    win.box()
    win.addstr(height - 1, label_x, esc_label)
    win.attroff(curses.color_pair(COLOR_PAIR_DARKER))
    win.addstr(height - 1, label_x + 2, "esc", curses.color_pair(COLOR_PAIR_HEADER))

def intro_window(stdscr):
    height, width = stdscr.getmaxyx()
    box_width = 50
    box_height = max(len(get_logo_lines()), 5) + 5
    box_y = (height - box_height) // 2
    box_x = (width - box_width) // 2
    intro_win = curses.newwin(box_height, box_width, box_y, box_x)
    popup_box(intro_win)
    return intro_win

def show_logo(win, final):
    logo_x = 4
    logo_y = 2
    logo_lines = get_logo_lines()

    # Scramble effect before revealing
    if not final:
        temp_lines = [['█' if ch != ' ' else ' ' for ch in line] for line in logo_lines]
        for idx, color in enumerate([234, 236, 58, 100, 136, 178, 220, 11, 11, 11, 11, 11, 11]):
            curses.init_pair(30 + idx, color, -1)
            for i, row in enumerate(temp_lines):
                line = ''.join(random.choice('▓ ▒ ░ ▀') if ch != ' ' else ' ' for ch in row)
                win.addstr(logo_y + i, logo_x, line, curses.color_pair(30 + idx) | curses.A_DIM)
            win.refresh()
            curses.napms(50)

    # Final logo render
    for i, line in enumerate(logo_lines):
        win.addstr(logo_y + i, logo_x, line, curses.color_pair(COLOR_PAIR_HEADER))
    win.refresh()
    curses.napms(400)

def fade_logo(win):
    logo_x = 4
    logo_y = 2
    logo_lines = get_logo_lines()
    for idx, color in enumerate([220, 178, 136, 100, 58, 236, 234]):
        curses.init_pair(30 + idx, color, -1)
        for i, line in enumerate(logo_lines):
            win.addstr(logo_y + i, logo_x, line, curses.color_pair(30 + idx) | curses.A_DIM)
        win.refresh()
        curses.napms(100)
        win.clear()

def shake_logo(win):
    logo_x = 4
    logo_y = 2
    logo_lines = get_logo_lines()
    for shake in [-1, 1, -1, 1, 0]:
        for i, line in enumerate(logo_lines): # Clean previous frame
            win.addstr(logo_y + i, logo_x, " " * (len(line)+1))
        win.refresh()
        for i, line in enumerate(logo_lines):
            win.addstr(logo_y + i, logo_x + shake, line, curses.color_pair(COLOR_PAIR_RED))
        win.refresh()
        curses.napms(50)
    show_logo(win, True)

def main(stdscr):
    curses.curs_set(0)
    curses.mousemask(curses.ALL_MOUSE_EVENTS | curses.REPORT_MOUSE_POSITION)
    curses.start_color()
    curses.use_default_colors()
    curses.init_pair(COLOR_PAIR_SELECTED, curses.COLOR_BLACK, curses.COLOR_CYAN)
    curses.init_pair(COLOR_PAIR_HEADER, curses.COLOR_YELLOW, -1)
    curses.init_pair(COLOR_PAIR_MENU, curses.COLOR_BLACK, curses.COLOR_YELLOW)
    curses.init_pair(COLOR_PAIR_FKEYS, curses.COLOR_BLACK, curses.COLOR_WHITE)
    curses.init_pair(COLOR_PAIR_ACTIVE, 231, -1)
    curses.init_pair(COLOR_PAIR_INACTIVE, curses.COLOR_WHITE, -1)
    curses.init_pair(COLOR_PAIR_WARN, curses.COLOR_BLACK, 202)
    curses.init_pair(COLOR_PAIR_DARK, 245, -1)
    curses.init_pair(COLOR_PAIR_GREEN, curses.COLOR_GREEN, -1)
    curses.init_pair(COLOR_PAIR_RED, curses.COLOR_RED, -1)
    curses.init_pair(COLOR_PAIR_EXPIRED, 203, -1)
    curses.init_pair(COLOR_PAIR_DARKER, 239, -1)

    intro_win = intro_window(stdscr)
    show_logo(intro_win, False)

    password = ""
    if not check_password(KEYSTORE_PATH, ""):
        password = prompt_password(intro_win)
    else:
        fade_logo(intro_win)

    try:
        entries = get_keystore_entries(KEYSTORE_PATH, password)
    except Exception as e:
        stdscr.clear()
        stdscr.addstr(0, 2, str(e))
        stdscr.getch()
        return

    selected = 0
    scroll_offset = 0
    detail_scroll = 0
    active_panel = 0

    has_unsaved_changes = False

    while True:
        draw_ui(stdscr, entries, selected, scroll_offset, detail_scroll, active_panel, has_unsaved_changes)
        key = stdscr.getch()

        height, width = stdscr.getmaxyx()
        panel_height = height - 4  # Subtract top and bottom padding (borders)

        if key == curses.KEY_MOUSE:
            try:
                _, mx, my, _, mouse_event = curses.getmouse()

                if my == 1 and width // 2 - 6 <= mx < width // 2:
                    selected = 0  # Top click
                    scroll_offset = 0
                elif my == height - 2 and width // 2 - 6 <= mx < width // 2:
                    selected = len(entries) - 1
                    scroll_offset = max(0, len(entries) - panel_height)

                if 1 < my < height - 2:
                    if 0 < mx < width // 2:
                        active_panel = LEFT_PANEL
                    elif mx >= width // 2:
                        active_panel = RIGHT_PANEL

                if mouse_event & 0x80000:
                    if active_panel == LEFT_PANEL and selected > 0:
                        selected -= 1
                        if selected < scroll_offset:
                            scroll_offset -= 1
                        detail_scroll = 0
                    elif active_panel == RIGHT_PANEL and detail_scroll > 0:
                        detail_scroll -= 1

                elif mouse_event & 0x8000000:
                    if active_panel == LEFT_PANEL and selected < len(entries) - 1:
                        selected += 1
                        if selected >= scroll_offset + panel_height:
                            scroll_offset += 1
                        detail_scroll = 0
                    elif active_panel == RIGHT_PANEL:
                        detail_scroll += 1

            except curses.error:
                pass

        elif key == curses.KEY_UP:
            if active_panel == LEFT_PANEL:
                if selected > 0:
                    selected -= 1
                    if selected < scroll_offset:
                        scroll_offset -= 1
                detail_scroll = 0
            elif active_panel == RIGHT_PANEL and detail_scroll > 0:
                detail_scroll -= 1

        elif key == curses.KEY_DOWN:
            if active_panel == LEFT_PANEL:
                if selected < len(entries) - 1:
                    selected += 1
                    if selected >= scroll_offset + panel_height:
                        scroll_offset += 1
                detail_scroll = 0
            elif active_panel == RIGHT_PANEL:
                detail_scroll += 1

        elif key == ord('t'):
            if active_panel == LEFT_PANEL:
                selected = 0
                scroll_offset = 0
            else:
                detail_scroll = 0

        elif key == ord('b'):
            if active_panel == LEFT_PANEL:
                selected = len(entries) - 1
                scroll_offset = max(0, len(entries) - panel_height)
            else:
                detail_scroll = max(0, len(entries[selected].get("__rendered__", [])) - 1)

        elif key == ord('\t') or key == 9:
            active_panel = RIGHT_PANEL if active_panel == LEFT_PANEL else LEFT_PANEL

        elif key == curses.KEY_F3:
            alias = import_cert_file(stdscr, password)
            entries = get_keystore_entries(KEYSTORE_PATH, password)
            selected = find_entry_index_by_alias(entries, alias)
            has_unsaved_changes = check_unsaved_changes()

        elif key == curses.KEY_F4:
            choice = prompt_import_key_type(stdscr)
            if choice == "PKCS #12":
                form_data = prompt_import_pkcs12_form(stdscr)
                if form_data:
                    alias = import_pkcs12_keypair(stdscr, KEYSTORE_PATH, password, form_data["key_file"], form_data["password"])
                    entries = get_keystore_entries(KEYSTORE_PATH, password)
                    selected = find_entry_index_by_alias(entries, alias)
                    has_unsaved_changes = check_unsaved_changes()
            elif choice == "PKCS #8":
                form_data = prompt_import_pkcs8_form(stdscr)
                if form_data:
                    alias = import_pkcs8_keypair(stdscr, KEYSTORE_PATH, password, form_data)
                    entries = get_keystore_entries(KEYSTORE_PATH, password)
                    selected = find_entry_index_by_alias(entries, alias)
                    has_unsaved_changes = check_unsaved_changes()

        elif key == curses.KEY_F5:
            alias = import_cert_from_url(stdscr, password)
            entries = get_keystore_entries(KEYSTORE_PATH, password)
            selected = find_entry_index_by_alias(entries, alias)
            has_unsaved_changes = check_unsaved_changes()

        elif key == curses.KEY_F7:
            has_unsaved_changes = save_changes(has_unsaved_changes)

        elif key == curses.KEY_F8:
            has_unsaved_changes = delete_entry(password, entries[selected].get("Alias name"))
            entries = get_keystore_entries(KEYSTORE_PATH, password)
            selected = min(selected, len(entries) - 1)

        elif key in [curses.KEY_F10, ord('q'), ord('Q'), 27]:
            has_unsaved_changes = save_changes(has_unsaved_changes)
            break

        if has_unsaved_changes:
            if selected == len(entries) - 1:
                scroll_offset = max(0, len(entries) - panel_height)

curses.wrapper(main)
