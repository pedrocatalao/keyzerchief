#!/usr/bin/env python3

import curses
import subprocess
import shutil
import tempfile
import sys
import os

# Config from argument
if len(sys.argv) < 2:
    print("Usage: keystoreterm <keystore-file>")
    sys.exit(1)

ORIGINAL_KEYSTORE_PATH = sys.argv[1]
if not os.path.isfile(ORIGINAL_KEYSTORE_PATH):
    print(f"File not found: {ORIGINAL_KEYSTORE_PATH}")
    sys.exit(1)

KEYSTORE_COPY_PATH = tempfile.NamedTemporaryFile(delete=False, suffix=".jks").name
shutil.copyfile(ORIGINAL_KEYSTORE_PATH, KEYSTORE_COPY_PATH)
KEYSTORE_PATH = KEYSTORE_COPY_PATH

# Colors
COLOR_PAIR_SELECTED = 1
COLOR_PAIR_HEADER = 2
COLOR_PAIR_MENU = 3
COLOR_PAIR_FKEYS = 4
COLOR_PAIR_ACTIVE = 5
COLOR_PAIR_INACTIVE = 6
COLOR_PAIR_WARN = 7

# Mouse support constants
LEFT_PANEL = 0
RIGHT_PANEL = 1

KEY_IMPORT_TYPES = ["PKCS #12", "PKCS #8", "PVK", "OpenSSL"]

def prompt_import_pkcs12_form(stdscr):
    curses.echo()
    height, width = stdscr.getmaxyx()
    win_width = 60
    win_height = 12
    start_y = (height - win_height) // 2
    start_x = (width - win_width) // 2

    win = curses.newwin(win_height, win_width, start_y, start_x)
    win.keypad(True)
    win.box()
    win.addstr(1, 2, "Import PKCS #12 Key Pair")

    labels = ["Key pair file:", "Decryption password:"]
    values = ["", ""]
    field_count = len(labels)
    current = 0

    selected_button = 0

    in_buttons = False

    while True:
        for i, label in enumerate(labels):
            win.addstr(3 + i, 2, label + " " * (18 - len(label)))
            attr = curses.A_REVERSE if (not in_buttons and i == current) else curses.A_NORMAL
            display_value = values[i] if i == 0 else '*' * len(values[i])
            win.addstr(3 + i, 22, display_value.ljust(30), attr)

        # Clear the button row
        win.addstr(7, 2, " " * (win_width - 4))

        import_attr = curses.A_REVERSE if in_buttons and selected_button == 0 else curses.A_NORMAL
        cancel_attr = curses.A_REVERSE if in_buttons and selected_button == 1 else curses.A_NORMAL

        win.addstr(7, 2, "[", curses.A_BOLD)
        win.addstr(" Import ", import_attr | curses.A_BOLD)
        win.addstr("]   [", curses.A_BOLD)
        win.addstr(" Cancel ", cancel_attr | curses.A_BOLD)
        win.addstr("]", curses.A_BOLD)

        if not in_buttons:
            cursor_x = 22 + len(display_value)
            win.move(3 + current, cursor_x)

        win.refresh()
        key = win.getch()

        if not in_buttons:
            if key == curses.KEY_UP and current > 0:
                current -= 1
            elif key == curses.KEY_DOWN:
                if current < field_count - 1:
                    current += 1
                else:
                    in_buttons = True
                    selected_button = 0
            elif key in [curses.KEY_BACKSPACE, 127, 8]:
                if values[current]:
                    values[current] = values[current][:-1]
            elif 32 <= key <= 126:
                if len(values[current]) < 30:
                    values[current] += chr(key)
        else:
            if key in [curses.KEY_LEFT, curses.KEY_RIGHT]:
                selected_button = 1 - selected_button
            elif key in [10, 13]:
                if selected_button == 0 and all(values):
                    curses.noecho()
                    return {
                        "key_file": values[0].strip(),
                        "password": values[1].strip()
                    }
                else:
                    return None
            elif key == curses.KEY_UP:
                in_buttons = False

        if key == 27:
            return None

def import_pkcs12_keypair(stdscr, keystore_path, keystore_pass, key_file, key_pass):
    stdscr.clear()
    stdscr.addstr(0, 2, "Importing key pair...", curses.A_BOLD)
    stdscr.refresh()

    alias = os.path.splitext(os.path.basename(key_file))[0]
    cmd = [
        "keytool", "-importkeystore",
        "-srckeystore", key_file,
        "-srcstoretype", "PKCS12",
        "-destkeystore", keystore_path,
        "-deststorepass", keystore_pass,
        "-srcstorepass", key_pass,
        "-alias", alias,
        "-destalias", alias
    ]
    result = subprocess.run(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
    stdscr.clear()
    if result.returncode == 0:
        stdscr.addstr(2, 2, f"Successfully imported: {alias}", curses.A_BOLD)
        return alias
    else:
        stdscr.addstr(2, 2, "Import failed:", curses.A_BOLD)
        stdscr.addstr(4, 2, result.stderr.strip())
    stdscr.addstr(6, 2, "Press any key to continue.")
    stdscr.refresh()
    stdscr.getch()

def import_pkcs8_keypair(stdscr, keystore_path, keystore_pass, form_data):
    alias = os.path.splitext(os.path.basename(form_data['key_file']))[0]

    pkcs8_cmd = [
        "openssl", "pkcs8",
        "-topk8",
        "-inform", "PEM",
        "-outform", "PEM",
        "-in", form_data['key_file'],
        "-passin", f"pass:{form_data['password']}" if form_data['encrypted'] else "pass:",
        "-out", "/tmp/converted_pkcs8.key"
    ]

    cmd = [
        "keytool", "-importcert",
        "-keystore", keystore_path,
        "-storepass", keystore_pass,
        "-alias", alias,
        "-file", form_data['cert_file'],
        "-keypass", form_data['password'] if form_data['encrypted'] else keystore_pass
    ]

    # Run OpenSSL to convert key
    openssl_result = subprocess.run(pkcs8_cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
    stdscr.clear()
    if openssl_result.returncode != 0:
        stdscr.addstr(0, 2, "OpenSSL conversion failed:", curses.A_BOLD)
        stdscr.addstr(2, 2, openssl_result.stderr.strip())
    else:
        keytool_result = subprocess.run(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
        if keytool_result.returncode == 0:
            stdscr.addstr(0, 2, f"Successfully imported: {alias}", curses.A_BOLD)
            return alias
        else:
            stdscr.addstr(0, 2, "Import failed:", curses.A_BOLD)
            stdscr.addstr(2, 2, keytool_result.stderr.strip())
    stdscr.addstr(4, 2, "Press any key to continue.")
    stdscr.refresh()
    stdscr.getch()

def prompt_import_pkcs8_form(stdscr):
    curses.echo()
    height, width = stdscr.getmaxyx()
    win_width = 70
    win_height = 13
    start_y = (height - win_height) // 2
    start_x = (width - win_width) // 2

    win = curses.newwin(win_height, win_width, start_y, start_x)
    win.keypad(True)
    win.box()
    win.addstr(1, 2, "Import PKCS #8 Key Pair")

    encrypted = True
    labels = ["Certificates file:", "PKCS#8 key file:", "Decryption password:"]
    values = ["", "", ""]
    current = 0
    selected_button = 0
    in_buttons = False

    while True:
        win.addstr(3, 2, "Encrypted Private Key:")
        yes_attr = curses.color_pair(COLOR_PAIR_SELECTED) if encrypted else curses.A_NORMAL
        no_attr = curses.color_pair(COLOR_PAIR_SELECTED) if not encrypted else curses.A_NORMAL
        if current == -2:
            yes_attr |= curses.A_BOLD
            no_attr |= curses.A_BOLD
        win.addstr(3, 26, " Yes ", yes_attr)
        win.addstr(3, 33, " No ", no_attr)

        field_index = 0
        for i, label in enumerate(labels):
            y_pos = 5 + i
            if not encrypted and i == 2:
                win.move(y_pos, 2)
                win.clrtoeol()
                continue
            else:
                win.addstr(y_pos, 2, label)

            field_index = i
            is_selected = (not in_buttons and current == field_index)
            attr = curses.A_REVERSE if is_selected else curses.A_NORMAL

            if i == 2:
                display_value = '*' * len(values[i])
            else:
                display_value = values[i]

            win.addstr(y_pos, 26, display_value[-30:].ljust(40), attr)

        win.addstr(11, 2, " " * (win_width - 4))
        import_attr = curses.A_REVERSE if in_buttons and selected_button == 0 else curses.A_NORMAL
        cancel_attr = curses.A_REVERSE if in_buttons and selected_button == 1 else curses.A_NORMAL

        win.addstr(11, 2, "[", curses.A_BOLD)
        win.addstr(" Import ", import_attr | curses.A_BOLD)
        win.addstr("]   [", curses.A_BOLD)
        win.addstr(" Cancel ", cancel_attr | curses.A_BOLD)
        win.addstr("]", curses.A_BOLD)

        if not in_buttons:
            if current >= 0:
                y_cursor = 5 + current
                x_cursor = 26 + len(values[current])
                win.move(y_cursor, x_cursor)

        win.refresh()
        key = win.getch()

        if current == -2:
            if key in [10, 13]:
                encrypted = not encrypted
            elif key == curses.KEY_LEFT:
                encrypted = True
            elif key == curses.KEY_RIGHT:
                encrypted = False
            elif key == curses.KEY_DOWN:
                current = 0
        elif not in_buttons:
            field_count = 3 if encrypted else 2
            if key == curses.KEY_UP:
                if current > 0:
                    current -= 1
                else:
                    current = -2
            elif key == curses.KEY_DOWN:
                if current < field_count - 1:
                    current += 1
                else:
                    in_buttons = True
                    selected_button = 0
            elif key in [curses.KEY_BACKSPACE, 127, 8]:
                if values[current]:
                    values[current] = values[current][:-1]
            elif 32 <= key <= 126:
                if len(values[current]) < 60:
                    values[current] += chr(key)
        else:
            if key in [curses.KEY_LEFT, curses.KEY_RIGHT]:
                selected_button = 1 - selected_button
            elif key in [10, 13]:
                if selected_button == 0:
                    curses.noecho()
                    return {
                        "encrypted": encrypted,
                        "key_file": values[0].strip(),
                        "cert_file": values[1].strip(),
                        "password": values[2].strip(),
                    }
                else:
                    return None
            elif key == curses.KEY_UP:
                in_buttons = False

        if key == 27:
            return None

def prompt_import_key_type(stdscr):
    height, width = stdscr.getmaxyx()
    win_height = len(KEY_IMPORT_TYPES) + 4
    win_width = max(len(t) for t in KEY_IMPORT_TYPES) + 10
    win = curses.newwin(win_height, win_width, (height - win_height) // 2, (width - win_width) // 2)
    win.keypad(True)
    win.box()
    win.addstr(1, 2, "Import Key Pair")
    selected = 0

    while True:
        for i, option in enumerate(KEY_IMPORT_TYPES):
            mode = curses.A_REVERSE if i == selected else curses.A_NORMAL
            win.addstr(3 + i, 4, option.ljust(win_width - 8), mode)
        win.refresh()
        key = win.getch()
        if key == curses.KEY_UP and selected > 0:
            selected -= 1
        elif key == curses.KEY_DOWN and selected < len(KEY_IMPORT_TYPES) - 1:
            selected += 1
        elif key in [10, 13]:
            return KEY_IMPORT_TYPES[selected]
        elif key in [27]:
            return None

def import_cert_file(stdscr, password):
    curses.echo()
    height, width = stdscr.getmaxyx()
    win_width = 60
    win_height = 7
    start_y = (height - win_height) // 2
    start_x = (width - win_width) // 2

    win = curses.newwin(win_height, win_width, start_y, start_x)
    win.box()
    win.addstr(1, 2, "Import Certificate File")
    win.addstr(3, 2, "Path to certificate file:")
    win.refresh()

    input_win = curses.newwin(1, win_width - 4, start_y + 4, start_x + 2)
    curses.curs_set(1)
    input_win.keypad(True)
    value = ""
    while True:
        input_win.clear()
        input_win.addstr(0, 0, value)
        input_win.refresh()
        ch = input_win.getch()
        if ch in [10, 13]:
            break
        elif ch in [27]:
            return None
        elif ch in [curses.KEY_BACKSPACE, 127, 8]:
            value = value[:-1]
        elif 32 <= ch <= 126:
            if len(value) < win_width - 6:
                value += chr(ch)

    curses.curs_set(0)
    curses.noecho()

    cert_file = value.strip()
    if cert_file and os.path.isfile(cert_file):
        alias = os.path.splitext(os.path.basename(cert_file))[0]
        import_cmd = [
            "keytool", "-importcert",
            "-alias", alias,
            "-keystore", KEYSTORE_PATH,
            "-storepass", password,
            "-file", cert_file,
            "-noprompt"
        ]
        stdscr.clear()
        stdscr.addstr(2, 2, f"Importing {cert_file}...", curses.A_BOLD)
        stdscr.refresh()
        result = subprocess.run(import_cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
        if result.returncode == 0:
            stdscr.addstr(4, 2, f"Successfully imported: {alias}", curses.A_BOLD)
            stdscr.addstr(6, 2, "Press any key to continue.")
            stdscr.refresh()
            stdscr.getch()
            return alias
        else:
            stdscr.addstr(4, 2, "Import failed:", curses.A_BOLD)
            stdscr.addstr(6, 2, result.stderr.strip())
            stdscr.addstr(8, 2, "Press any key to continue.")
            stdscr.refresh()
            stdscr.getch()
    return None

def import_cert_from_url(stdscr, password):
    url = prompt_url_input(stdscr)
    stdscr.clear()
    stdscr.addstr(0, 2, f"Fetching certificate from {url}...", curses.A_BOLD)
    stdscr.refresh()

    try:
        for prefix in ["https://", "http://", "https:/", "http:/"]:
            if url.startswith(prefix):
                url = url[len(prefix):]

        parts = url.split(":")
        host = parts[0]
        port = parts[1] if len(parts) > 1 else "443"

        cert_path = f"/tmp/cert_from_{url.replace(':', '_').replace('/', '_')}.crt"
        cmd = [
            "openssl", "s_client", "-showcerts",
            "-servername", host,
            "-connect", f"{host}:{port}"
        ]
        fetch = subprocess.run(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.DEVNULL, text=True, timeout=5)
        print(fetch.stdout)
        start = fetch.stdout.find("-----BEGIN CERTIFICATE-----")
        end = fetch.stdout.find("-----END CERTIFICATE-----") + len("-----END CERTIFICATE-----")
        cert = fetch.stdout[start:end]

        if "-----BEGIN CERTIFICATE-----" not in cert:
            raise Exception("Could not extract certificate")

        with open(cert_path, "w") as f:
            f.write(cert)

        alias = url.split(':')[0]
        import_cmd = [
            "keytool", "-importcert",
            "-alias", alias,
            "-keystore", KEYSTORE_PATH,
            "-storepass", password,
            "-file", cert_path,
            "-noprompt"
        ]
        result = subprocess.run(import_cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
        stdscr.clear()
        if result.returncode == 0:
            stdscr.addstr(2, 2, f"Successfully imported cert from {url}", curses.A_BOLD)
            return alias
        else:
            stdscr.addstr(2, 2, "Import failed:", curses.A_BOLD)
            stdscr.addstr(4, 2, result.stderr.strip())

    except Exception as e:
        stdscr.addstr(2, 2, f"Error: {str(e)}", curses.A_BOLD)

    stdscr.addstr(4, 2, "Press any key to continue.")
    stdscr.refresh()
    stdscr.getch()


def prompt_url_input(stdscr):
    curses.echo()
    height, width = stdscr.getmaxyx()
    win_width = 60
    win_height = 7
    start_y = (height - win_height) // 2
    start_x = (width - win_width) // 2

    win = curses.newwin(win_height, win_width, start_y, start_x)
    win.box()
    win.addstr(1, 2, "Import SSL Certificate from Website")
    win.addstr(3, 2, "Hostname:Port (e.g. example.com:443):")
    win.refresh()

    input_win = curses.newwin(1, win_width - 4, start_y + 4, start_x + 2)
    curses.curs_set(1)
    input_win.keypad(True)
    value = ""
    while True:
        input_win.clear()
        input_win.addstr(0, 0, value)
        input_win.refresh()
        ch = input_win.getch()
        if ch in [10, 13]:
            break
        elif ch in [27]:
            return None
        elif ch in [curses.KEY_BACKSPACE, 127, 8]:
            value = value[:-1]
        elif 32 <= ch <= 126:
            if len(value) < win_width - 6:
                value += chr(ch)

    curses.curs_set(0)
    curses.noecho()
    return value.strip()

def keystore_has_password(keystore_path):
    try:
        subprocess.run(
            ["keytool", "-list", "-keystore", keystore_path, "-storepass", ""],
            check=True,
            stdout=subprocess.DEVNULL,
            stderr=subprocess.DEVNULL
        )
        return False
    except subprocess.CalledProcessError:
        return True

def prompt_password(stdscr):
    while True:
        stdscr.clear()
        curses.noecho()
        height, width = stdscr.getmaxyx()
        prompt = "Enter keystore password: "
        stdscr.addstr(height // 2, (width - len(prompt)) // 2, prompt)
        stdscr.refresh()

        win = curses.newwin(1, 30, height // 2, (width + len(prompt)) // 2)
        win.keypad(True)
        password = ""

        while True:
            ch = win.getch()
            if ch in [10, 13]:  # Enter
                break
            elif ch in [27]:  # ESC
                return ""
            elif ch in [curses.KEY_BACKSPACE, 127, 8]:
                if len(password) > 0:
                    password = password[:-1]
                    win.delch(0, len(password))
                    win.move(0, len(password))
            elif 32 <= ch <= 126:
                if len(password) < 30:
                    password += chr(ch)
                    win.addch(0, len(password) - 1, '*')

        try:
            _ = get_keystore_entries(KEYSTORE_PATH, password)
            return password
        except Exception as e:
            stdscr.addstr(height // 2 + 2, (width - len(str(e))) // 2, str(e), curses.A_BOLD | curses.color_pair(COLOR_PAIR_HEADER))

            # Retry confirmation popup
            confirm_height, confirm_width = 5, 40
            confirm_y = (height - confirm_height) // 2
            confirm_x = (width - confirm_width) // 2
            confirm_win = curses.newwin(confirm_height, confirm_width, confirm_y, confirm_x)
            confirm_win.keypad(True)
            confirm_win.box()
            confirm_win.addstr(1, 2, "Password incorrect. Retry?")

            selected_option = 0
            options = ["Yes", "No"]

            while True:
                for i, label in enumerate(options):
                    attr = curses.A_REVERSE if i == selected_option else curses.A_NORMAL
                    confirm_win.addstr(3, 2 + i * 10, f" {label} ", attr)
                confirm_win.refresh()
                k = confirm_win.getch()
                if k in [curses.KEY_LEFT, curses.KEY_RIGHT]:
                    selected_option = 1 - selected_option
                elif k in [10, 13]:
                    break

            if selected_option == 0:
                continue  # Retry input
            else:
                exit(1)

def check_unsaved_changes():
    try:
        with open(ORIGINAL_KEYSTORE_PATH, 'rb') as f1, open(KEYSTORE_PATH, 'rb') as f2:
            return f1.read() != f2.read()
    except Exception:
        return True

def get_keystore_entries(path, password):
    cmd = ["keytool", "-list", "-v", "-keystore", path, "-storepass", password]
    result = subprocess.run(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
    if result.returncode != 0:
        raise Exception("Failed to load keystore:\n" + result.stderr)

    entries = []
    current_entry = {}
    lines = result.stdout.splitlines()[4:]  # Skip first 4 lines
    for line in lines:
        line = line.strip()
        if line.startswith("Alias name:"):
            if current_entry:
                entries.append(current_entry)
            current_entry = {"Alias name": line.split("Alias name:")[1].strip()}
        elif ":" in line:
            key, value = map(str.strip, line.split(":", 1))
            current_entry[key] = value
    if current_entry:
        entries.append(current_entry)

    # Pre-render each entry's details into strings
    for entry in entries:
        detail_lines = []
        priority = ["Alias name", "Entry type", "Creation date"]
        keys = priority + [k for k in entry if k not in priority]
        for key in keys:
            value = entry.get(key, "")
            detail_lines.append((key, value))
        entry["__rendered__"] = detail_lines

    return entries

def find_entry_index_by_alias(entries, alias):
    for i, entry in enumerate(entries):
        if entry.get("Alias name") == alias:
            return i
    return 0

def draw_ui(stdscr, entries, selected, scroll_offset, detail_scroll, active_panel, has_unsaved_changes):
    stdscr.clear()
    height, width = stdscr.getmaxyx()
    panel_width = width // 2
    max_detail_width = width - panel_width - 5
    visible_height = height - 4

    # Menu bar
    stdscr.attron(curses.color_pair(COLOR_PAIR_MENU))
    stdscr.addstr(0, 0, " " * width)
    stdscr.addstr(0, 1, " Left      File      Options      Right ")
    stdscr.attroff(curses.color_pair(COLOR_PAIR_MENU))

    # Left panel box
    stdscr.addch(1, 0, curses.ACS_ULCORNER)
    stdscr.addch(1, panel_width - 1, curses.ACS_URCORNER)
    stdscr.hline(1, 1, curses.ACS_HLINE, panel_width - 2)
    stdscr.addstr(1, panel_width - 8, "─┤")
    stdscr.addstr("t", curses.color_pair(COLOR_PAIR_HEADER))
    stdscr.addstr("op├─")
    stdscr.addstr(1, 3, f" Keystore: {ORIGINAL_KEYSTORE_PATH} ", curses.color_pair(COLOR_PAIR_HEADER))
    stdscr.addch(height - 2, 0, curses.ACS_LLCORNER)
    stdscr.addch(height - 2, panel_width - 1, curses.ACS_LRCORNER)
    stdscr.hline(height - 2, 1, curses.ACS_HLINE, panel_width - 2)
    for y in range(2, height - 2):
        stdscr.addch(y, 0, curses.ACS_VLINE)
        stdscr.addch(y, panel_width - 1, curses.ACS_VLINE)

    # Right panel box
    stdscr.addch(1, panel_width, curses.ACS_ULCORNER)
    stdscr.addch(1, width - 1, curses.ACS_URCORNER)
    stdscr.hline(1, panel_width + 1, curses.ACS_HLINE, width - panel_width - 2)
    stdscr.addstr(1, panel_width + 3, " Details ", curses.color_pair(COLOR_PAIR_HEADER))
    stdscr.addch(height - 2, panel_width, curses.ACS_LLCORNER)
    stdscr.addch(height - 2, width - 1, curses.ACS_LRCORNER)
    stdscr.hline(height - 2, panel_width + 1, curses.ACS_HLINE, width - panel_width - 2)
    for y in range(2, height - 2):
        stdscr.addch(y, panel_width, curses.ACS_VLINE)
        stdscr.addch(y, width - 1, curses.ACS_VLINE)

    stdscr.attroff(curses.color_pair(COLOR_PAIR_HEADER))

    if selected < scroll_offset:
        scroll_offset = selected
    elif selected >= scroll_offset + visible_height:
        scroll_offset = selected - visible_height + 1

    for i in range(scroll_offset, min(len(entries), scroll_offset + visible_height)):
        entry = entries[i]
        alias = entry.get("Alias name", "<unknown>")
        y_pos = 2 + i - scroll_offset
        if y_pos >= height - 2:
            break
        if active_panel == LEFT_PANEL:
            attr = curses.color_pair(COLOR_PAIR_SELECTED) if i == selected else curses.color_pair(COLOR_PAIR_ACTIVE)
        else:
            attr = curses.color_pair(COLOR_PAIR_INACTIVE)
        stdscr.addstr(y_pos, 2, alias[:panel_width - 3], attr)

    # Right panel
    stdscr.attroff(curses.color_pair(COLOR_PAIR_HEADER))

    detail_lines = entries[selected].get("__rendered__", [])[detail_scroll:]
    line_num = 2
    for key, value in detail_lines:
        lines = [value[i:i+max_detail_width] for i in range(0, len(value), max_detail_width)]
        if line_num >= height - 2:
            break
        attr = curses.color_pair(COLOR_PAIR_ACTIVE if active_panel == RIGHT_PANEL else COLOR_PAIR_INACTIVE)
        stdscr.addstr(line_num, panel_width + 2, f"{key}:", curses.A_UNDERLINE | attr)
        line_num += 1
        for l in lines:
            if line_num >= height - 2:
                break
            stdscr.addstr(line_num, panel_width + 4, l, attr)
            line_num += 1

    # Draw Footer
    footer_options = [" 1Help", " 2GenKeyPair", " 3ImpCert", " 4ImpKeyPair", " 5ImpFromWeb", " 6SetPwd", " 7Save", " 8Delete", " 9PullDn", "10Quit"]
    spacing = width // len(footer_options)
    for i, item in enumerate(footer_options):
        label = item[2:]
        prefix = item[:2]
        if "Save" in label and has_unsaved_changes:
            attr = curses.color_pair(COLOR_PAIR_WARN)
        else:
            attr = curses.color_pair(COLOR_PAIR_FKEYS)
        stdscr.addstr(height - 1, i * spacing, prefix, attr)
        stdscr.addstr(height - 1, i * spacing + 2, label.ljust(spacing - 2), curses.color_pair(COLOR_PAIR_HEADER))

    stdscr.refresh()

def main(stdscr):
    curses.curs_set(0)
    curses.mousemask(curses.ALL_MOUSE_EVENTS | curses.REPORT_MOUSE_POSITION)
    curses.start_color()
    curses.use_default_colors()
    curses.init_pair(COLOR_PAIR_SELECTED, curses.COLOR_BLACK, curses.COLOR_CYAN)
    curses.init_pair(COLOR_PAIR_HEADER, curses.COLOR_YELLOW, -1)
    curses.init_pair(COLOR_PAIR_MENU, curses.COLOR_BLACK, curses.COLOR_YELLOW)
    curses.init_pair(COLOR_PAIR_FKEYS, curses.COLOR_BLACK, curses.COLOR_WHITE)
    curses.init_pair(COLOR_PAIR_ACTIVE, 231, -1)
    curses.init_pair(COLOR_PAIR_INACTIVE, curses.COLOR_WHITE, -1)
    curses.init_pair(COLOR_PAIR_WARN, curses.COLOR_BLACK, 202)

    password = ""
    if keystore_has_password(KEYSTORE_PATH):
        password = prompt_password(stdscr)

    try:
        entries = get_keystore_entries(KEYSTORE_PATH, password)
    except Exception as e:
        stdscr.clear()
        stdscr.addstr(0, 2, str(e))
        stdscr.getch()
        return

    selected = 0
    scroll_offset = 0
    detail_scroll = 0
    active_panel = 0

    has_unsaved_changes = False

    while True:
        draw_ui(stdscr, entries, selected, scroll_offset, detail_scroll, active_panel, has_unsaved_changes)
        key = stdscr.getch()

        if key == curses.KEY_MOUSE:
            try:
                _, mx, my, _, mouse_event = curses.getmouse()

                height, width = stdscr.getmaxyx()
                panel_width = width // 2
                if 1 < my < height - 2:
                    if 0 < mx < panel_width:
                        active_panel = LEFT_PANEL
                    elif panel_width <= mx < width:
                        active_panel = RIGHT_PANEL

                if mouse_event & 0x80000:  # Scroll up
                    if active_panel == LEFT_PANEL and selected > 0:
                        selected -= 1
                    elif active_panel == RIGHT_PANEL and detail_scroll > 0:
                        detail_scroll -= 1
                elif mouse_event & 0x8000000:  # Scroll down
                    if active_panel == LEFT_PANEL and selected < len(entries) - 1:
                        selected += 1
                    elif active_panel == RIGHT_PANEL:
                        detail_scroll += 1
            except curses.error:
                pass

        if key == curses.KEY_UP:
            if active_panel == 0 and selected > 0:
                selected -= 1
            elif active_panel == 1 and detail_scroll > 0:
                detail_scroll -= 1
        elif key == curses.KEY_DOWN:
            if active_panel == 0 and selected < len(entries) - 1:
                selected += 1
            elif active_panel == 1:
                detail_scroll += 1
        elif key == ord('t'):  # Home or Fn+Up
            if active_panel == LEFT_PANEL:
                selected = 0
            else:
                detail_scroll = 0
        elif key == ord('b'):  # End or Fn+Down
            if active_panel == LEFT_PANEL:
                selected = len(entries) - 1
            else:
                detail_scroll = max(0, len(entries[selected].get("__rendered__", [])) - 1)
        elif key == ord('\t') or key == 9:
            active_panel = 1 if active_panel == 0 else 0
        elif key == curses.KEY_F8:
            alias = entries[selected].get("Alias name")
            confirm_height, confirm_width = 7, 50
            confirm_y = (curses.LINES - confirm_height) // 2
            confirm_x = (curses.COLS - confirm_width) // 2
            confirm_win = curses.newwin(confirm_height, confirm_width, confirm_y, confirm_x)
            confirm_win.keypad(True)
            confirm_win.box()
            confirm_win.addstr(1, 2, f"Delete entry '{alias}'?")
            options = ["Yes", "No"]
            selected_option = 1
            while True:
                for i, label in enumerate(options):
                    attr = curses.A_REVERSE if i == selected_option else curses.A_NORMAL
                    confirm_win.addstr(5, 2 + i * 10, f" {label} ", attr)
                confirm_win.refresh()
                ch = confirm_win.getch()
                if ch in [curses.KEY_LEFT, curses.KEY_RIGHT]:
                    selected_option = 1 - selected_option
                elif ch in [10, 13]:
                    break

            if selected_option == 0:
                delete_cmd = ["keytool", "-delete", "-alias", alias, "-keystore", KEYSTORE_PATH, "-storepass", password]
                result = subprocess.run(delete_cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
                if result.returncode == 0:
                    entries = get_keystore_entries(KEYSTORE_PATH, password)
                    selected = min(selected, len(entries) - 1)
                    has_unsaved_changes = check_unsaved_changes()
                else:
                    stdscr.clear()
                    stdscr.addstr(0, 2, "Deletion failed:", curses.A_BOLD)
                    stdscr.addstr(2, 2, result.stderr.strip())
                    stdscr.refresh()
                    stdscr.getch()

        elif key in [ord('q'), ord('Q'), 27, curses.KEY_F10]:
            if has_unsaved_changes:
                confirm_height, confirm_width = 7, 50
                confirm_y = (curses.LINES - confirm_height) // 2
                confirm_x = (curses.COLS - confirm_width) // 2
                confirm_win = curses.newwin(confirm_height, confirm_width, confirm_y, confirm_x)
                confirm_win.keypad(True)
                confirm_win.box()
                confirm_win.addstr(1, 2, "Exit without saving?")
                confirm_win.addstr(3, 2, "Unsaved changes will be lost.")

                selected_option = 1
                options = ["Yes", "No"]

                while True:
                    for i, label in enumerate(options):
                        attr = curses.A_REVERSE if i == selected_option else curses.A_NORMAL
                        confirm_win.addstr(5, 2 + i * 10, f" {label} ", attr)
                    confirm_win.refresh()
                    ch = confirm_win.getch()
                    if ch in [curses.KEY_LEFT, curses.KEY_RIGHT]:
                        selected_option = 1 - selected_option
                    elif ch in [10, 13]:
                        break

                if selected_option == 0:
                    break
            else:
                break

        elif key == curses.KEY_F5:
            alias = import_cert_from_url(stdscr, password)
            entries = get_keystore_entries(KEYSTORE_PATH, password)
            selected = find_entry_index_by_alias(entries, alias)
            has_unsaved_changes = check_unsaved_changes()

        elif key == curses.KEY_F3:
            alias = import_cert_file(stdscr, password)
            entries = get_keystore_entries(KEYSTORE_PATH, password)
            selected = find_entry_index_by_alias(entries, alias)
            has_unsaved_changes = check_unsaved_changes()

        elif key == curses.KEY_F4:
            choice = prompt_import_key_type(stdscr)
            if choice == "PKCS #12":
                form_data = prompt_import_pkcs12_form(stdscr)
                if form_data:
                    alias = import_pkcs12_keypair(stdscr, KEYSTORE_PATH, password, form_data["key_file"], form_data["password"])
                    entries = get_keystore_entries(KEYSTORE_PATH, password)
                    selected = find_entry_index_by_alias(entries, alias)
                    has_unsaved_changes = check_unsaved_changes()
            elif choice == "PKCS #8":
                form_data = prompt_import_pkcs8_form(stdscr)
                if form_data:
                    alias = import_pkcs8_keypair(stdscr, KEYSTORE_PATH, password, form_data)
                    entries = get_keystore_entries(KEYSTORE_PATH, password)
                    selected = find_entry_index_by_alias(entries, alias)
                    has_unsaved_changes = check_unsaved_changes()

        elif key == curses.KEY_F7:
            confirm_height, confirm_width = 7, 50
            confirm_y = (curses.LINES - confirm_height) // 2
            confirm_x = (curses.COLS - confirm_width) // 2
            confirm_win = curses.newwin(confirm_height, confirm_width, confirm_y, confirm_x)
            confirm_win.keypad(True)
            confirm_win.box()
            confirm_win.addstr(1, 2, "Confirm Overwrite")
            confirm_win.addstr(3, 2, "Overwrite the original keystore?")

            selected_option = 0
            options = ["Yes", "No"]

            while True:
                for i, label in enumerate(options):
                    attr = curses.A_REVERSE if i == selected_option else curses.A_NORMAL
                    confirm_win.addstr(5, 2 + i * 10, f" {label} ", attr)
                confirm_win.refresh()
                ch = confirm_win.getch()
                if ch in [curses.KEY_LEFT, curses.KEY_RIGHT]:
                    selected_option = (selected_option + 1) % len(options)
                elif ch in [10, 13]:
                    break

            if selected_option == 0:
                shutil.copyfile(KEYSTORE_PATH, ORIGINAL_KEYSTORE_PATH)
                has_unsaved_changes = check_unsaved_changes()
                # Saving animation
                confirm_win.addstr(5, 2, "Saving:")
                for i in range(30):
                    confirm_win.addstr(5, 10 + i, "█")
                    confirm_win.refresh()
                    curses.napms(20)

curses.wrapper(main)
